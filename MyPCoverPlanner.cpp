#include "MyPCoverPlanner.h"
#include "MyGame.h"
#include "MyDragonAgent.h"
#include "tsp/GraphTSP.h"
#include <algorithm>
#include "glpk/glpk.h" //linear programming solver
#include <map>

using namespace mathtool;

namespace GMUCS425
{

int MyPCoverPlanner::PCOVER_FLAG=INT_MAX-1;

int gcd(int a, int b)
{
    for (;;)
    {
        if (a == 0) return b;
        b %= a;
        if (b == 0) return a;
        a %= b;
    }
    return 0;
}

int lcm(int a, int b)
{
    int temp = gcd(a, b);
    return temp ? (a / temp * b) : 0;
}

float MyPCoverPlanner::dist2time(float dist)
{
  return (float)ceil(dist*5);//distance * 5 = time to travel
}

//estimate the cost of travelling from pos1 to pos2
//scaled using the values generated by Perlin noise
float MyPCoverPlanner::cost(const Point2d& pos1, const Point2d& pos2)
{
  return dist2time((pos1-pos2).norm());

  const Uint32 * terrain = m_scene->get_terrain();
  int terrain_width = getMyGame()->getScreenWidth();
  int terrain_height = getMyGame()->getScreenHeight();
  Point2d mid( (pos1[0]+pos2[0])/2, (pos1[1]+pos2[1])/2 );
  Uint32 watery=terrain[((int)mid[1])*terrain_width+((int)mid[0])] & 255;
  float scale=sqrt(sqrt(watery*1.0f/255)); //0~1
  return (1+scale) * (pos1-pos2).norm();
}

//------------
bool MyPCoverPlanner::build() //build a grid or graph
{
  if(!m_grid.empty()) return false; //build only if the grid is empty

  m_grid=std::vector< std::vector<Node> >( m_height, std::vector<Node>(m_width,Node()) );
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  //TODO: go through the nodes, and init the data for each node
  int nid=0;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      n.id=nid++;
      n.pos.set( cell_w*(j+0.5f), cell_h*(i+0.5f) );
      //check if the node is free of collision
      n.free = !collision_detection(n.pos);
      //cout<<"node ("<<j<<","<<i<<") is free="<<n.free<<endl;
    }//end j
  }//end i

  //Make connections
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      //connect the neighboring cells
      for(int dx=-1;dx<2;dx++)
      {
        int nj=j+dx;
        if(nj<0 || nj>=m_width) continue;
        for(int dy=-1;dy<2;dy++)
        {
          int ni=i+dy;
          if(ni<0 || ni>=m_height) continue;
          Node & nei = m_grid[ni][nj];
          if(&nei==&n) continue; //the node itself

          if(collision_detection(n.pos, nei.pos)) continue; //not passable
          float dist=cost(n.pos, nei.pos);
          if(nei.free) n.neighbors.push_back( make_pair(&nei,dist));
        }//end for dy
      }//end for dx
      //cout<<"n has "<<n.neighbors.size()<<" neis"<<endl;
    }//end j
  }//end i

  return true;
}

// //check if the schedule with the new duration would be valid
// bool MyPCoverPlanner::isvalid(MySchedule& s, Node * new_n)
// {
//   if(new_duration>this->m_battery+10) return false;
//   if(new_duration>this->)
// }

//schedule
bool MyPCoverPlanner::schedule( const Point2d& start )
{
  m_schedules.clear();

  //check if the start is valid (i.e., inside the screen)
  if(start[0]<0 || start[1]>=getMyGame()->getScreenWidth()) return false;

  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  Node * S=&m_grid[(int)(start[1]/cell_h)][(int)(start[0]/cell_w)];
  if(m_charging_station!=NULL) m_charging_station->b_charging_station=false;
  S->b_charging_station = true;
  m_charging_station=S;

  //compute path to charging station
  cout<<"- Compute all paths from charging station"<<endl;
  m_num_valid_cells=-1;
  if( paths2station()==false ) return false;

  //build dijkstra tree
  dijkstra(m_charging_station);

  cout<<"m_opt_method="<<m_opt_method<<endl;
  //schedule!
  int trial=20;
  if(m_opt_method=="tsp_greedy")
    schedule_tsp_segments_greedy(trial);
  else if(m_opt_method=="tsp_lp")
    schedule_tsp_segments_lp(trial);
  else if(m_opt_method=="tsp_lp2")
    schedule_tsp_segments_lp2(trial);
  else if(m_opt_method=="shortest_lp")
    schedule_shorest_paths_lp();
  else if(m_opt_method=="lollipop_lp")
      schedule_lollipop_lp();
  else if(m_opt_method=="lollipop_lp2")
      schedule_lollipop_lp2();
  else if(m_opt_method=="dijkstra_lp")
      schedule_dijkstra_lp();
  else if(m_opt_method=="hybrid")
      schedule_hybrid(5);
  else if(m_opt_method=="rolling")
      schedule_rolling();
  else{
    cerr<<"! Error: Unknown pcover optimization method: "<<m_opt_method<<endl;
    exit(1);
  }

//exit(1);
  //
  return true;
}

//shortest path LP uses the shortest path to every node
//as the tour
void MyPCoverPlanner::schedule_shorest_paths_lp()
{
  vector<MySchedule> schedules;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors

      MySchedule schedule;
      const auto & path=n.path2station;
      schedule.insert(schedule.end(), path.begin(), path.end() );
      schedule.insert(schedule.end(), path.rbegin(), path.rend() );
      schedule.nodes=visitedNodes(schedule,0);

      // cout<<"nodes:";
      // for(auto n : schedule.nodes) cout<<n->id<<",";
      // cout<<endl;

      //schedule.nodes.push_back(&n);
      schedule.duration=n.time2station*2;

      schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);

      // cout<<"schedule.chicken_needed="<<schedule.chicken_needed<<endl;
      // cout<<"schedule size="<<schedule.nodes.size()<<endl;

      schedules.push_back(schedule);
    }
  }

  //find optimal subset
  int total_chickens_needed=SolveLP(schedules, m_schedules);
  cout<<"- Best schedule needs "<<total_chickens_needed<<" UAVs and "<<m_schedules.size()<<" tours"<<endl;
}

bool MyPCoverPlanner::schedule_tsp_segments_lp(int trials)
{
  //
  vector<TSP> tours;
  tsp(m_charging_station,tours,trials);
  //assert(tour.front().first==m_charging_station);

  int best_tour=0;
  int min_chickens_needed=INT_MAX;
  vector<MySchedule> best_m_schedules;

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    //int total_chickens_needed=0;
    vector<MySchedule> schedules;
    m_schedules.clear();

    //break TSP into segments
    for(auto it=tour.begin(); it!=tour.end(); it++)
    {
        //MySchedule schedule;
        build_valid_schedule_from_tsp(tour, it, schedules);
        //cout<<"schedules.size()="<<schedules.size()<<endl;
        //schedules.push_back(schedule);
    }//end for tour

    //build constraints
    /*
    list<LP_constraints> constraints;
    vector<float> solution; //0/1
    int total_chickens_needed=0;
    generate_constraints(schedules, constraints);

    if(tour.size()!=constraints.size())
    {
      cerr<<"! Error: LP constraint size inconsistent"<<endl;
      exit(1);
    }

    //cout<<"constraints size="<<constraints.size()<<endl;
    if( SolveLP(schedules, constraints, solution) )
    {
      int size=solution.size();
      //cout<<"solution=";
      for(int i=0;i<size;i++){
        if(solution[i]>0.5){
          //cout<<i<<",";
          m_schedules.push_back(schedules[i]);
          total_chickens_needed+=schedules[i].chicken_needed;
        }
      }//end for i
      //cout<<endl;
    }
    else continue;
    */
    int total_chickens_needed=SolveLP(schedules,m_schedules);
    //check if this schedule is better
    //cout<<"trial #"<<i<<" needs "<<total_chickens_needed<<" chickens"<<endl;
    //cout<<total_chickens_needed<<endl;
    if(total_chickens_needed<min_chickens_needed)
    {
      min_chickens_needed=total_chickens_needed;
      best_m_schedules=m_schedules;
    }

  }//end for i

  //failed...no LP solved
  if(min_chickens_needed==INT_MAX) return false;

  cout<<"- Best schedule needs "<<min_chickens_needed<<" UAVs and "<<best_m_schedules.size()<<" tours"<<endl;
  m_schedules=best_m_schedules;
  return true;

}//end MyPCoverPlanner

bool MyPCoverPlanner::schedule_tsp_segments_lp2(int trials)
{
  //
  vector<TSP> tours;
  tsp(m_charging_station,tours,trials);
  vector<MySchedule> schedules;

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    //break TSP into segments
    for(auto it=tour.begin(); it!=tour.end(); it++)
    {
        build_valid_schedule_from_tsp(tour, it, schedules);
    }//end for tour
  }

#if 00 //on/off timed schedule
  //
  vector<MyTimedSchedule> tschedules;
  for(auto& schedule : schedules) schedule2timedschedules(schedule,tschedules);

  cout<<"------- schedules size="<<schedules.size()<<endl;
  cout<<"------- timed schedules size="<<tschedules.size()<<endl;
  for(MyTimedSchedule & ts : tschedules)
  {
    assert(ts.arrival_times.size()==ts.nodes.size());
    auto atime=ts.arrival_times.begin();
    //cout<<"TS="<<&ts;
    for(Node * node : ts.nodes)
    {
      node->timed_schedules.push_back(make_pair(*atime,&ts));
      //cout<<" visiting node="<<node->id<<" arrival="<<*atime<<endl;
      atime++;
    }
  }


  //get timed schedules
  {
    m_timed_schedules.clear();
    int total_chickens_needed=SolveLP(m_timed_schedules);
    cout<<"- Best schedule needs "<<total_chickens_needed
        <<" chickens and "<<m_timed_schedules.size()<<" tours"<<endl;

    return true;
  }
  //
#endif

  int total_chickens_needed=SolveLP(schedules,m_schedules);

  cout<<"- Best schedule needs "<<total_chickens_needed
      <<" UAVs and "<<m_schedules.size()<<" tours"<<endl;

  return true;
}//end MyPCoverPlanner

void MyPCoverPlanner::schedule_tsp_segments_greedy(int trials)
{
  //
  vector<TSP> tours;
  tsp(m_charging_station,tours,trials);
  //assert(tour.front().first==m_charging_station);

  int best_tour=0;
  int min_chickens_needed=INT_MAX;
  vector<MySchedule> best_m_schedules;

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    int total_chickens_needed=0;
    m_schedules.clear();
    //break TSP into segments
    for(TSP::const_iterator it=tour.begin(); it!=tour.end(); it++)
    {
      MySchedule schedule;
      it=build_valid_schedule_from_tsp(tour, it, schedule);
      total_chickens_needed+=schedule.chicken_needed;
      m_schedules.push_back(schedule);
      // cout<<"schedule=";
      // for(Node * n : schedule.nodes)
      // {
      //   cout<<n->id<<"->";
      // }
      // cout<<" cost="<<schedule.chicken_needed<<endl;
    }//end for tour

    //cout<<"trial #"<<i<<" needs "<<total_chickens_needed<<" chickens"<<endl;
    //cout<<total_chickens_needed<<endl;
    if(total_chickens_needed<min_chickens_needed)
    {
      min_chickens_needed=total_chickens_needed;
      best_m_schedules=m_schedules;
    }
  }//end for i trials

  cout<<"- Best schedule needs "<<min_chickens_needed<<" UAVs and "<<best_m_schedules.size()<<" tours"<<endl;
  m_schedules=best_m_schedules;

  //for displaying failed scenarios
  //for(auto & schedule : m_schedules) schedule.chicken_needed/=2;
}

//lollipop tours
void MyPCoverPlanner::schedule_dijkstra_lp()
{
  //for each node, create a lollipop
  vector<MySchedule> schedules;
  cout<<"root id="<<m_charging_station->id<<endl;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors

      //
      //if(&n!=this->m_charging_station) continue;
      //if(n.id!=24) continue;
      //

      cout<<"processing id="<<n.id<<endl;
      vector<Node*> desendents;
      vector<MyPCoverPlanner::TSP> TSPs;
      get_desendents(&n,desendents);
      desendents.push_back(&n);

      if(desendents.size()<4) continue;

      tsp_easy(desendents,&n,TSPs,1);

      Lollipop lollipop=tsp2lollipop(TSPs.front());
      if(lollipop.time_needed>m_battery) continue;

      float battery=this->m_battery-n.time2station*2;
      float latency=this->m_latency-n.time2station;
      if(battery<=0 || latency<=0) continue;//no time/power left

      //optimize_lollipop_simple2(lollipop,battery,latency);
      MySchedule schedule=lollipop2schedule(lollipop);
      lollipop.destroy();
      //if(schedule.duration>m_battery) continue;
      schedules.push_back(schedule);
    }
  }

//  m_schedules=schedules;
//  return;

  //find optimal subset
  int total_chickens_needed=SolveLP(schedules, m_schedules);
  cout<<"- Best schedule needs "<<total_chickens_needed<<" UAVs and "<<m_schedules.size()<<" tours"<<endl;
}

//lollipop tours
void MyPCoverPlanner::schedule_lollipop_lp()
{
  //for each node, create a lollipop
  vector<MySchedule> schedules;
  cout<<"root id="<<m_charging_station->id<<endl;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors

      //
      //if(&n!=this->m_charging_station) continue;
      //if(n.id!=87) continue;
      //
      Lollipop lollipop=build_lollipop(&n,0);
      if(lollipop.head==NULL) continue; //invalid lollipop
      MySchedule schedule=lollipop2schedule(lollipop);
      schedules.push_back(schedule);
      lollipop.destroy();
    }
  }

  //m_schedules=schedules;
  //return;

  //find optimal subset
  int total_chickens_needed=SolveLP(schedules, m_schedules);
  cout<<"- Best schedule needs "<<total_chickens_needed<<" UAVs and "<<m_schedules.size()<<" tours"<<endl;
}

bool MyPCoverPlanner::schedule_hybrid(int trials)
{
  vector<MySchedule> schedules;

  /*
  vector<TSP> tours;
  tsp(m_charging_station,tours,trials);

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    //break TSP into segments
    for(auto it=tour.begin(); it!=tour.end(); it++)
    {
        build_valid_schedule_from_tsp(tour, it, schedules);
    }//end for tour
  }

  //now add tour from lollipop
  vector< pair<float, Node*> > sorted_nodes;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      if(&n==this->m_charging_station) continue;
      sorted_nodes.push_back(make_pair(-n.dist2station, &n));
    }//end j
  }//end i

  sort(sorted_nodes.begin(),sorted_nodes.end());
  set<Node *> nodes_covered;

  for(auto& data : sorted_nodes)
  {
    Node & n=*(data.second);
    cout<<"working on node "<<n.id<<" distance="<<n.dist2station<<endl;
    vector<Lollipop> lollipops=build_lollipops(&n,0);
    for(Lollipop & lollipop : lollipops)
    {
      MySchedule schedule=lollipop2schedule(lollipop);
      schedules.push_back(schedule);
      lollipop.destroy();
      nodes_covered.insert(schedule.nodes.begin(),schedule.nodes.end());
    }//for each lollipop

    cout<<"- covered "<<nodes_covered.size()<<"/"<<m_num_valid_cells<<" cells,"
        <<" schedule size="<<schedules.size()<<endl;

    if(m_num_valid_cells==nodes_covered.size())
     break; //done
  }//for data
  */

  collect_schedules(schedules, trials, true);

  int total_chickens_needed=SolveLP(schedules,m_schedules);

  cout<<"- Best schedule needs "<<total_chickens_needed
      <<" UAVs and "<<m_schedules.size()<<" tours"<<endl;

  return true;
}//end MyPCoverPlanner



//lollipop tours
void MyPCoverPlanner::schedule_lollipop_lp2()
{
  //for each node, create a lollipop
  vector<MySchedule> schedules;
  cout<<"root id="<<m_charging_station->id<<endl;

  vector< pair<float, Node*> > sorted_nodes;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      //if(&n==this->m_charging_station) continue;
      sorted_nodes.push_back(make_pair(-n.dist2station, &n));
    }//end j
  }//end i

  sort(sorted_nodes.begin(),sorted_nodes.end());
  set<Node *> nodes_covered;

  for(auto& data : sorted_nodes)
  {
    Node & n=*(data.second);
    cout<<"working on node "<<n.id<<" distance="<<n.dist2station<<endl;
    //
    //if(&n!=this->m_charging_station) continue;
    if(n.id!=20) continue;
    //
    vector<Lollipop> lollipops=build_lollipops(&n,0);
    //cout<<"!!!!!!!"<<endl;
    int count=20;
    map<int,int> states;
    cout<<"lollipops size="<<lollipops.size()<<endl;
    for(Lollipop & lollipop : lollipops)
    {
      if(count++!=1) continue;
      //cout<<"?? lollipop.count="<<lollipop.count<<endl;

      MySchedule schedule=lollipop2schedule(lollipop);
      if( m_battery-schedule.duration>750 ) continue;
      states[lollipop.count]++;
      schedules.push_back(schedule);
      lollipop.destroy();
      nodes_covered.insert(schedule.nodes.begin(),schedule.nodes.end());
      break;
    }//for each lollipop

    cout<<"- covered "<<nodes_covered.size()<<"/"<<m_num_valid_cells<<" cells,"
        <<" schedule size="<<schedules.size()<<endl;

    //if(m_num_valid_cells==nodes_covered.size())
    // break; //done

    for(auto s : states)
    {
      cout<<"count "<<s.first<<" has "<<s.second<<endl;
    }
  }//for data

  //exit(1);
  m_schedules=schedules;
  return;

  //find optimal subset
  int total_chickens_needed=SolveLP(schedules, m_schedules);
  cout<<"- Best schedule needs "<<total_chickens_needed<<" UAVs and "<<m_schedules.size()<<" tours"<<endl;

  exit(1);
}

//rolling based scheduling
bool MyPCoverPlanner::schedule_rolling()
{
  //create n flexible timed schedules
  vector<MyTimedSchedule> confirmed_ts;
  vector<MyTimedSchedule> all_ts;
  unordered_map< Node*, unordered_set<MyTimedSchedule*> > N2S; //node to schedules
  unordered_map< Node*, MyInterval > last_visits; //last visited time interval

  {
    //get schedules for the first rounds
    vector<MySchedule> all_schedules;
    collect_schedules(all_schedules, 10, true);

    //find optimal init schedule
    vector<MySchedule> init_scheudles;
    SolveLP(all_schedules,init_scheudles);

    //convert initial schedules to timed schedules
    for(auto& schedule : init_scheudles){
      schedule.chicken_needed=1; //create 1 timed tour
      schedule2timedschedules(schedule,confirmed_ts);
    }

    //record schedules from nodes' perspective
    for(auto& s : all_schedules){
      s.chicken_needed=1; //create 1 timed tour
      schedule2timedschedules(s,all_ts);
      MyTimedSchedule& ts=all_ts.back();
      list<Node *> nodes = visitedNodes(ts); //collect all nodes passed through
      for(Node * n : nodes) N2S[n].insert(&ts);
    }
  }

  //assign comfirmed schedule to nodes
  for(auto & ts : confirmed_ts)
  {
    for(auto& data : ts.getTT()) //(node,time)
    {
      //the time that this schedule arrived at this node
      //departure time + travel time (atime)
      double at=data.second+ts.start_time;
      Node *node=data.first;
      node->timed_schedules.push_back({at,&ts});
    }
  }//end of for(ts)

  list< pair<float, Node*> > nodes_with_problem; //witness and node
  for(int i=0;i<m_height;i++){
    for(int j=0;j<m_width;j++){
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      if(&n==this->m_charging_station) continue;
      sort(n.timed_schedules.begin(), n.timed_schedules.end());
      double witness;
      if(is_pcovered(&n, witness)) continue;
      nodes_with_problem.push_back({witness,&n});
    }
  }

  //get schedules for the rest of runs
  bool pcovered=false; //does the map is p-covered
  while(!nodes_with_problem.empty()){ //proposing new schedules while the graph is not pcovered

    vector<MyTimedSchedule> proposed_ts;

    for(auto& node : nodes_with_problem){

        // check if the proposed schedule of n may cover n
        Node * n = node.second;
        double max_w =node.first;  //previous witness
        for(MyTimedSchedule& ts : proposed_ts){
          double witness;
          if(is_pcovered(n, &ts, witness)) continue;
          if(witness>max_w) max_w=witness;
        }

        //no proposed schedule that can improve the latency violation
        //propose new schedules with the needed start time
        if(max_w == node.first){
          unordered_set<MyTimedSchedule*> & schedules = N2S[n];
          for(MyTimedSchedule* ts:schedules){
            //create timed schedule that pushes max_w as far as possible
            double travel_time=ts->getTT().at(n);
            MyTimedSchedule newts(*ts);
            newts.start_time=max_w-travel_time; //need to arrive at max_w
            proposed_ts.push_back(newts);
          }
        }

    }//end n

    //find the minimum set of proposed schedule
    vector<MyTimedSchedule> new_confirmed_ts;
    {
      list<Node *> nodes;
      for(auto& data: nodes_with_problem) nodes.push_back(data.second);
      SolveLP(nodes, proposed_ts, new_confirmed_ts);
    }

    //add solution to comfirmed schedule
    for(MyTimedSchedule& ts : new_confirmed_ts){
      for(auto& data : ts.getTT())
      {
        //the time that this schedule arrived at this node
        //departure time + travel time (atime)
        double at=data.second+ts.start_time;
        Node *node=data.first;
        node->timed_schedules.push_back({at,&ts});
      }
    }

    //check if the nodes are pcovered now
    list< pair<float, Node*> > nodes_still_with_problem;
    for(auto& data : nodes_with_problem){
      double witness;
      Node * n =data.second;
      if(is_pcovered(n, witness)) continue;
      nodes_still_with_problem.push_back({witness,n});
    }

    nodes_with_problem.swap(nodes_still_with_problem);
  }

  return true;
}//end MyPCoverPlanner


void MyPCoverPlanner::collect_schedules
(vector<MySchedule>& schedules, int tsp_trials, bool do_lollipop)
{
  vector<TSP> tours;
  tsp(m_charging_station,tours,tsp_trials);

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    //break TSP into segments
    for(auto it=tour.begin(); it!=tour.end(); it++)
    {
        build_valid_schedule_from_tsp(tour, it, schedules);
    }//end for tour
  }

  if(!do_lollipop) return; //done

  //now add tour from lollipop
  vector< pair<float, Node*> > sorted_nodes;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      if(&n==this->m_charging_station) continue;
      sorted_nodes.push_back(make_pair(-n.dist2station, &n));
    }//end j
  }//end i

  sort(sorted_nodes.begin(),sorted_nodes.end());
  set<Node *> nodes_covered;

  for(auto& data : sorted_nodes)
  {
    Node & n=*(data.second);
    cout<<"working on node "<<n.id<<" distance="<<n.dist2station<<endl;
    vector<Lollipop> lollipops=build_lollipops(&n,0);
    for(Lollipop & lollipop : lollipops)
    {
      MySchedule schedule=lollipop2schedule(lollipop);
      schedules.push_back(schedule);
      lollipop.destroy();
      nodes_covered.insert(schedule.nodes.begin(),schedule.nodes.end());
    }//for each lollipop

    cout<<"- covered "<<nodes_covered.size()<<"/"<<m_num_valid_cells<<" cells,"
        <<" schedule size="<<schedules.size()<<endl;

    if(m_num_valid_cells==nodes_covered.size())
     break; //done
  }//for data

  return; //done with collecting schedules
}

// ----------------------------------------------------------------------------
//
// lollipop helpers
//
// ----------------------------------------------------------------------------

// build many lollipop tours for a given node n
//
vector<MyPCoverPlanner::Lollipop>
MyPCoverPlanner::build_lollipops
(MyPCoverPlanner::Node * n, float start_time)
{
  vector<Lollipop> lollipops;
  float battery=this->m_battery-n->time2station*2;
  float latency=this->m_latency-n->time2station;
  if(battery<=0 || latency<=0) return lollipops;//no time/power left

  //mark the visited nodes
  auto visited_nodes=visitedNodes(n->path2station,0);
  for(Node * m : visited_nodes) m->flag=n->id;

  //init the process with a simple loop
  Lollipop lollipop=init_lollipop(n,battery,latency);
  if(lollipop.head==NULL) return lollipops;
  //optimize_lollipop(lollipop,battery,latency);
  //optimize_lollipop_simple(lollipop,battery,latency);
  //optimize_lollipop_simple2(lollipop,battery,latency);

  // lollipops.push_back(lollipop);
  // return lollipops;

  //now expand the loop
  //int count=0;
  set<MyPCoverPlanner::Lollipop> open;
  set<MyPCoverPlanner::Lollipop> closed;
  open.insert(lollipop);
  while(open.empty()==false)
  {
    //cout<<"open size="<<open.size()<<", closed size="<<closed.size()<<endl;

    Lollipop lollipop=*open.begin();
    open.erase(open.begin());

    float battery=this->m_battery-lollipop.entrance->time2station-lollipop.exit->time2station;
    float latency=this->m_latency-lollipop.entrance->time2station;

    //cout<<"battery="<<battery<<endl;
    //cout<<"latency="<<latency<<endl;

    //expand this lollipop, if failed, then close it
    if( !expand_lollipop(lollipop, open, battery,latency) )
    {
      // if(optimize_lollipop_simple2(lollipop,battery,latency))
      //   open.insert(lollipop);
      // else
        closed.insert(lollipop);
    }
  }

  lollipops=vector<Lollipop>(closed.begin(), closed.end());
  return lollipops;
}

//
// build many lollipop tours for a given node n
// ignoring latency constraints
//
vector<MyPCoverPlanner::Lollipop>
MyPCoverPlanner::build_lollipops_ignoring_latency
(MyPCoverPlanner::Node * n)
{
  vector<Lollipop> lollipops;
  float battery=this->m_battery-n->time2station*2;
  const float latency=FLT_MAX;
  if(battery<=0) return lollipops;//no power left

  //mark the visited nodes
  auto visited_nodes=visitedNodes(n->path2station,0);
  for(Node * m : visited_nodes) m->flag=n->id;

  //init the process with a simple loop
  Lollipop lollipop=init_lollipop(n,battery,latency);
  if(lollipop.head==NULL) return lollipops;

  //now expand the loop
  set<MyPCoverPlanner::Lollipop> open;
  set<MyPCoverPlanner::Lollipop> closed;
  open.insert(lollipop);
  while(open.empty()==false)
  {
    Lollipop lollipop=*open.begin();
    open.erase(open.begin());
    float battery=this->m_battery-lollipop.entrance->time2station-lollipop.exit->time2station;
    //expand this lollipop, if failed, then close it
    if( !expand_lollipop(lollipop, open, battery,latency) )
        closed.insert(lollipop);
  }

  lollipops=vector<Lollipop>(closed.begin(), closed.end());
  return lollipops;
}


//build a lollipop tour
MyPCoverPlanner::Lollipop
MyPCoverPlanner::build_lollipop
(MyPCoverPlanner::Node * n, float start_time)
{
  Lollipop lollipop;
  float battery=this->m_battery-n->time2station*2;
  float latency=this->m_latency-n->time2station;
  if(battery<=0 || latency<=0) return lollipop;//no time/power left

  //mark the visited nodes
  auto visited_nodes=visitedNodes(n->path2station,0);
  for(Node * m : visited_nodes) m->flag=n->id;

  //init the process with a simple loop
  lollipop=init_lollipop(n,battery,latency);
  if(lollipop.head==NULL) return lollipop;
  //optimize_lollipop(lollipop,battery,latency);
  //optimize_lollipop_simple(lollipop,battery,latency);
  optimize_lollipop_simple2(lollipop,battery,latency);

  //now expand the loop
  //int count=0;
  while(true)
  {
    float battery=this->m_battery-lollipop.entrance->time2station-lollipop.exit->time2station;
    float latency=this->m_latency-lollipop.entrance->time2station;
    //cout<<"battery="<<battery<<endl;
    //cout<<"latency="<<latency<<endl;

    if(!expand_lollipop(lollipop,battery,latency))
    {
      //break;
      //if(!optimize_lollipop(lollipop,battery,latency)) break;
      //if(!optimize_lollipop_simple(lollipop,battery,latency)) break;
      if(!optimize_lollipop_simple2(lollipop,battery,latency)) break;
    }
  }

  return lollipop;
}

MyPCoverPlanner::MySchedule
MyPCoverPlanner::lollipop2schedule(MyPCoverPlanner::Lollipop & lollipop)
{
    MySchedule schedule;
    auto & path=lollipop.entrance->path2station;
    schedule.insert(schedule.end(),path.begin(),path.end());

    if(lollipop.best_tsp.empty())
    {
      auto ptr=lollipop.head;
      while(ptr->data!=lollipop.entrance) ptr=ptr->next;
      do
      {
        //cout<<"ptr->data="<<ptr->data->id<<endl;
        schedule.push_back(ptr->data->pos);
        ptr=ptr->next;
      }
      while(ptr->data!=lollipop.entrance);
    }
    else
    {
      //cout<<"AAAAAAAAAh"<<endl;
      for(Node * node : lollipop.best_tsp)
        schedule.push_back(node->pos);
    }

    auto& returnpath=lollipop.exit->path2station;
    schedule.insert(schedule.end(),returnpath.rbegin(),returnpath.rend());

    //cout<<"lollipop count="<<lollipop.count<<endl;
    //cout<<"lollipop_nodes size="<<lollipop_nodes.size()<<endl;
    schedule.duration=lollipop.time_needed+lollipop.entrance->time2station+lollipop.exit->time2station;
    schedule.nodes=visitedNodes(schedule,0);
    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);

    return schedule;
}

MyPCoverPlanner::Lollipop MyPCoverPlanner::init_lollipop
(MyPCoverPlanner::Node * n, float battery, float latency)
{
  Lollipop lollipop;
  lollipop.time_needed=0;
  n->flag=n->id;
  Lollipop_Node * ln0=new Lollipop_Node(n);
  assert(ln0);
  lollipop.insert(ln0);

  //get the second node
  pair<Node *, float> n2=getClosestFurtherNodes(n);

  if(n2.first==NULL) return lollipop;
  if(n2.second*2 > battery || n2.second>latency) return lollipop;
  n2.first->flag=n->id;
  Lollipop_Node * ln1=new Lollipop_Node(n2.first);
  assert(ln1);
  ln1->pre=ln0; ln1->next=ln0;
  ln1->pre_cost=n2.second;
  ln1->next_cost=n2.second;
  lollipop.insert(ln1);
  lollipop.time_needed=n2.second*2;

  //try to get the 3rd node
  pair< Node *, pair<float,float> > n3=getClosestCommonNeighbor(n,n2.first);

  if(n3.first==NULL) return lollipop;
  n3.first->flag=n->id;

  float total_cost=n2.second+n3.second.second+n3.second.first;
  if(total_cost > battery || total_cost>latency) return lollipop;

  //now we have 3 nodes, create a loop
  Lollipop_Node * ln2=new Lollipop_Node(n3.first);
  assert(ln2);
  ln2->pre=ln1; ln2->next=ln0;
  ln2->pre_cost=n3.second.second;
  ln2->next_cost=n3.second.first;
  lollipop.insert(ln2);
  lollipop.time_needed=total_cost;

  return lollipop;
}

bool MyPCoverPlanner::expand_lollipop
(MyPCoverPlanner::Lollipop & lollipop, float battery, float latency)
{
  //for each consecutive pair
  auto * ptr=lollipop.head;
  auto * next=ptr->next;
  float min_cost_increase=FLT_MAX;
  float min_dist=FLT_MAX;
  Lollipop_Node * best=new Lollipop_Node();

//cout<<"expand_lollipop next="<<next<<" head="<<lollipop.head<<endl;

  //while(next!=lollipop.head)
  do
  {
    //pair< Node *, pair<float,float> > n
    auto n=getClosestCommonNeighbor(ptr->data,next->data);
    if(n.first!=NULL){
      float increase=n.second.first+n.second.second-ptr->next_cost;
      //cout<<"\t add node "<<n.first->id<<" increase="<<increase<<endl;
      if(increase<min_cost_increase ||
         (min_cost_increase==increase && n.first->time2station>min_dist))
      {
        min_cost_increase=increase;
        min_dist=n.first->time2station;
        best->data=n.first;
        best->pre=ptr;
        best->next=next;
        best->pre_cost=n.second.first;
        best->next_cost=n.second.second;
      }
    }

    ptr=next;
    next=ptr->next;
  }while(ptr!=lollipop.head); //end while

  //
  if(best->data==NULL) return false; //failed

  float new_cost=lollipop.time_needed + min_cost_increase;
  //cout<<"new_cost="<<new_cost<<" min_cost_increase="<<min_cost_increase<<endl;
  if(new_cost>battery) return false; //exceeded needed power
  if(new_cost>latency) return false; //exceeded time

  best->data->flag=lollipop.head->data->id;
  lollipop.insert(best);

  //cout<<"expand ->"<<best->data->id<<" time need="<<lollipop.time_needed<<endl;
  return true;
}

//
// get a Lollipop_Node that this lollipop can expand to
//
// NOTE: getClosestCommonNeighbor uses node->flag to detect next expansion
//       therefore, find_next_expansion may return different node to expand
//       even if the same lollipop is given
//
MyPCoverPlanner::Lollipop_Node * MyPCoverPlanner::find_next_expansion
(MyPCoverPlanner::Lollipop & lollipop, float battery, float latency)
{
  //for each consecutive pair
  auto * ptr=lollipop.head;
  auto * next=ptr->next;
  float min_cost_increase=FLT_MAX;
  float min_dist=FLT_MAX;
  Lollipop_Node * best=new Lollipop_Node();

//cout<<"expand_lollipop next="<<next<<" head="<<lollipop.head<<endl;

  //while(next!=lollipop.head)
  do
  {
    //pair< Node *, pair<float,float> > n
    auto n=getClosestCommonNeighbor(ptr->data,next->data);
    if(n.first!=NULL){
      float increase=n.second.first+n.second.second-ptr->next_cost;
      //cout<<"\t add node "<<n.first->id<<" increase="<<increase<<endl;
      if(increase<min_cost_increase ||
         (min_cost_increase==increase && n.first->time2station>min_dist))
      {
        min_cost_increase=increase;
        min_dist=n.first->time2station;
        best->data=n.first;
        best->pre=ptr;
        best->next=next;
        best->pre_cost=n.second.first;
        best->next_cost=n.second.second;
      }
    }

    ptr=next;
    next=ptr->next;
  }
  while(ptr!=lollipop.head); //end while

  //
  bool failed=false;
  if(best->data==NULL) failed=true; //failed

  float new_cost=lollipop.time_needed + min_cost_increase;
  //cout<<"new_cost="<<new_cost<<" min_cost_increase="<<min_cost_increase<<endl;
  if(new_cost>battery) failed=true; //exceeded needed power
  if(new_cost>latency) failed=true; //exceeded time
  if(failed){ delete best; return NULL; }

  //cout<<"expand ->"<<best->data->id<<" time need="<<lollipop.time_needed<<endl;
  return best;
}

//expand a lollopop into multiple unique lollipops
bool MyPCoverPlanner::expand_lollipop
(MyPCoverPlanner::Lollipop & lollipop, set<MyPCoverPlanner::Lollipop>& expand,
 float battery, float latency)
{
//cout<<"X"<<endl;
  int expand_count=0;
  auto * ptr=lollipop.head;
  auto * next=ptr->next;

//cout<<"A"<<endl;

  //mark all nodes in the lollipop
  auto flag=getFlag();
  do{ ptr->data->flag=flag; ptr=ptr->next; }while(ptr!=lollipop.head);

//cout<<"B"<<endl;

  //expand
  ptr=lollipop.head;
  while(true)
  {
    //becuase of the flag, this function returns a different find_next_expansion
    Lollipop_Node * ln=find_next_expansion(lollipop,battery,latency);
    if(ln==NULL) break;
    ln->data->flag=flag; //mark as collected
    auto lollipop2=lollipop.clone();
    ln->pre=lollipop2.find(ln->pre->data);;
    ln->next=lollipop2.find(ln->next->data);
    lollipop2.insert(ln);
    expand.insert(lollipop2);
    expand_count++;
  }

//cout<<"C"<<endl;

  //cout<<"expand ->"<<best->data->id<<" time need="<<lollipop.time_needed<<endl;
  // cout<<"expand_count="<<expand_count<<endl;
  // cout<<"expand size="<<expand.size()<<endl;
  // cout<<"lollipop count="<<expand.begin()->count<<endl;

  return expand_count>0;
}


//convert the lollipop to a graph and find TSP
bool MyPCoverPlanner::optimize_lollipop
(MyPCoverPlanner::Lollipop & lollipop, float battery, float latency)
{
  if(lollipop.count<=3) return false; //too small

  //cout<<"---- optimize_lollipop ----"<<endl;
  //build subset
  //cout<<"build subset"<<endl;
  vector<Node*> subg;
  unordered_map<int, int> id2id;
  auto ptr=lollipop.head;
  int vid=0;

  do{
    Node * node=ptr->data;
    int oldid=node->id;
    node->id=vid++;
    id2id[node->id]=oldid;
    subg.push_back(node);
    ptr=ptr->next;
  }
  while(ptr!=lollipop.head);

  //cout<<"subset has "<< subg.size()<<" nodes"<<endl;

  //now run tsp
  subg.push_back(new Node());
  Node * dummy=subg.back();
  dummy->id=subg.size()-1;
  pair<Node *, Node *> best_pair;
  float min_time_needed=FLT_MAX;
  MyPCoverPlanner::TSP best_tsp;

  for(Node * n1 : subg)
  {
    if(n1==dummy) continue;
    for(Node * n2 : subg)
    {
      if(n2==dummy) continue;
      if(n1->id>n2->id) continue;
      dummy->neighbors.push_back( make_pair(n1,1.0f) );
      dummy->neighbors.push_back( make_pair(n2,1.0f) );
      n1->neighbors.push_back( make_pair(dummy,1.0f) );
      n2->neighbors.push_back( make_pair(dummy,1.0f) );
      //run tsp on this
      //cout<<"run tsp from n1="<<n1->id<<" n2="<<n2->id<<endl;
      vector<MyPCoverPlanner::TSP> TSPs;
      tsp(subg,dummy,TSPs, 1);
      if(TSPs.empty()) exit(1);//continue;
      //analyze this tsp
      MyPCoverPlanner::TSP & TSP=TSPs.front();
      //cout<<"TSP size="<<TSP.size()<<endl;
      float time_needed=n1->time2station+n2->time2station-2;
      for(auto & node : TSP)
      {
        //node.first->id=id2id[node.first->id]; //put the old id back
        time_needed+=node.second;
      }
      //
      //cout<<"time_needed="<<time_needed<<" TSP size="<<TSP.size()<<endl;
      if(time_needed<min_time_needed)
      {
        min_time_needed=time_needed;
        best_tsp=TSP;
        best_pair=make_pair((++TSP.begin())->first,TSP.back().first);
      }
      //
      n1->neighbors.pop_back();
      n2->neighbors.pop_back();
      dummy->neighbors.clear();
    }
  }
  //get tsp
  //cout<<"min_time_needed="<<min_time_needed<<endl;
  float orig_time_needed=lollipop.time_needed+lollipop.entrance->time2station+lollipop.exit->time2station;
  //cout<<"original time_needed="<<orig_time_needed<<endl;
  for(auto node : subg)
  {
    if(node==dummy) continue;
    node->id=id2id[node->id]; //put the old id back
  }

  //update with optimal solution
  if(min_time_needed<=orig_time_needed)
  {
    lollipop.entrance=best_pair.first;
    lollipop.exit=best_pair.second;

    cout<<"lollipop.entrance="<<lollipop.entrance->id<<endl;
    cout<<"lollipop.exit="<<lollipop.exit->id<<endl;

    lollipop.time_needed=min_time_needed-lollipop.entrance->time2station-lollipop.exit->time2station;
    //lollipop.best_tsp=best_tsp;
    lollipop.best_tsp.clear();
    for( auto n : best_tsp)
    {
      if(n.first==dummy) continue;
      lollipop.best_tsp.push_back(n.first);
    }//end for node
  }

  delete dummy;
  return orig_time_needed>min_time_needed;
}



//convert the lollipop to a graph and find TSP
bool MyPCoverPlanner::optimize_lollipop_simple
(MyPCoverPlanner::Lollipop & lollipop, float battery, float latency)
{
  auto ptr=lollipop.head;
  float orig_time_needed=lollipop.time_needed+lollipop.entrance->time2station+lollipop.exit->time2station;
  float min_time_needed=orig_time_needed;
  float loop_cost=lollipop.time_needed;
  if(lollipop.entrance!=lollipop.exit)
    loop_cost+=getWeight(lollipop.exit,lollipop.entrance);

  do{
    auto pre=ptr->pre;
    float time_needed=loop_cost-pre->next_cost+ptr->data->time2station+pre->data->time2station;

    if(time_needed<min_time_needed)
    {
      min_time_needed=time_needed;
      lollipop.entrance=ptr->data;
      lollipop.exit=pre->data;
      lollipop.time_needed=loop_cost-pre->next_cost;
    }
    ptr=ptr->next;
  }
  while(ptr!=lollipop.head);

  return orig_time_needed>min_time_needed;
}


//convert tsp to lollipop
MyPCoverPlanner::Lollipop MyPCoverPlanner::tsp2lollipop
(MyPCoverPlanner::TSP& tsp)
{
   cout<<"convert tsp to lollipop"<<endl;
   Lollipop lollipop;
   Lollipop_Node * n0=new Lollipop_Node(tsp.front().first);
   assert(n0);
   lollipop.insert(n0);
   Lollipop_Node * pre=n0;
   auto pre_it=tsp.begin();
   lollipop.count=tsp.size();
   lollipop.time_needed=0;
   for( auto it=++tsp.begin(); it!=tsp.end(); it++)
   {
     Lollipop_Node * n=new Lollipop_Node(it->first);
     assert(n);
     pre->next=n; n->pre=pre;
     pre->next_cost=n->pre_cost=pre_it->second;
     pre=n;
     pre_it=it;
     lollipop.time_needed+=pre_it->second;
   }//end for node
   //now, pre, is the last node
   pre->next=n0; n0->pre=pre;
   pre->next_cost=n0->pre_cost=tsp.back().second;
   lollipop.time_needed+=tsp.back().second;

   return lollipop;
}

//convert the lollipop to a graph and find TSP
bool MyPCoverPlanner::optimize_lollipop_simple2
(MyPCoverPlanner::Lollipop & lollipop, float battery, float latency)
{
  if(lollipop.count<=3) return false; //too small

  //cout<<"---- optimize_lollipop ----"<<endl;
  //build subset
  //cout<<"build subset"<<endl;
  vector<Node*> subg;
  unordered_map<int, int> id2id;
  auto ptr=lollipop.head;
  int vid=0;

  do{
    Node * node=ptr->data;
    int oldid=node->id;
    node->id=vid++;
    id2id[node->id]=oldid;
    subg.push_back(node);
    ptr=ptr->next;
  }
  while(ptr!=lollipop.head);

  //cout<<"subset has "<< subg.size()<<" nodes"<<endl;

  //now run tsp
  subg.push_back(new Node());
  Node * dummy=subg.back();
  dummy->id=subg.size()-1;
  pair<Node *, Node *> best_pair;
  float min_time_needed=FLT_MAX;
  MyPCoverPlanner::TSP best_tsp;

  for(auto it=subg.begin();it!=subg.end();it++)
  {
    Node * n1=*it;
    if(n1==dummy) continue;
    auto next=it; next++;
    if(next==subg.end()) next=subg.begin();
    Node * n2=*next;
    if(n2==dummy) continue;

    dummy->neighbors.push_back( make_pair(n1,1.0f) );
    dummy->neighbors.push_back( make_pair(n2,1.0f) );
    n1->neighbors.push_back( make_pair(dummy,1.0f) );
    n2->neighbors.push_back( make_pair(dummy,1.0f) );
    //run tsp on this
    //cout<<"run tsp from n1="<<n1->id<<" n2="<<n2->id<<endl;
    vector<MyPCoverPlanner::TSP> TSPs;
    tsp(subg,dummy,TSPs, 1);
    if(TSPs.empty()) exit(1);//continue;
    //analyze this tsp
    MyPCoverPlanner::TSP & TSP=TSPs.front();
    //cout<<"TSP size="<<TSP.size()<<endl;
    float time_needed=n1->time2station+n2->time2station-2;
    for(auto & node : TSP)
    {
      //node.first->id=id2id[node.first->id]; //put the old id back
      time_needed+=node.second;
    }
    //
    //cout<<"time_needed="<<time_needed<<" TSP size="<<TSP.size()<<endl;
    if(time_needed<min_time_needed)
    {
      min_time_needed=time_needed;
      best_tsp=TSP;
      best_pair=make_pair((++TSP.begin())->first,TSP.back().first);
    }
    //
    n1->neighbors.pop_back();
    n2->neighbors.pop_back();
    dummy->neighbors.clear();
  }

  //get tsp
  //cout<<"min_time_needed="<<min_time_needed<<endl;
  float orig_time_needed=lollipop.time_needed+lollipop.entrance->time2station+lollipop.exit->time2station;
  //cout<<"original time_needed="<<orig_time_needed<<endl;
  for(auto node : subg)
  {
    if(node==dummy) continue;
    node->id=id2id[node->id]; //put the old id back
  }

  //update with optimal solution
  if(min_time_needed<=orig_time_needed)
  {
    lollipop.entrance=best_pair.first;
    lollipop.exit=best_pair.second;

    //cout<<"lollipop.entrance="<<lollipop.entrance->id<<endl;
    //cout<<"lollipop.exit="<<lollipop.exit->id<<endl;

    lollipop.time_needed=min_time_needed-lollipop.entrance->time2station-lollipop.exit->time2station;
    //lollipop.best_tsp=best_tsp;
    lollipop.best_tsp.clear();
    for( auto n : best_tsp)
    {
      if(n.first==dummy) continue;
      lollipop.best_tsp.push_back(n.first);
    }//end for node
  }

  delete dummy;
  return orig_time_needed>min_time_needed;
}

//build a schedule from a tour and its starting node
//return the iterator of tour that cannot fit into this current schedule
MyPCoverPlanner::TSP::const_iterator
MyPCoverPlanner::build_valid_schedule_from_tsp
(const MyPCoverPlanner::TSP& tour,
 MyPCoverPlanner::TSP::const_iterator start,
 MySchedule& schedule)
{
    auto it=start; //the start of the schedule
    const int buffer=11;

    //first station must be charging station
    if(it->first!=m_charging_station)
    {
      schedule.insert(schedule.end(), it->first->path2station.begin(), it->first->path2station.end() );
    }
    else
    {
      schedule.push_back(it->first->pos);
    }

    schedule.duration=it->first->time2station*2; //round trip
    auto next=it;
    next++;

    while( next!=tour.end() )
    {
      //schedule.nodes.insert(it->first);
      schedule.nodes.push_back(it->first);
      //new arriva time = current tour duration - return_time + time to next node
      float new_arrival=schedule.duration-it->first->time2station+it->second;
      //new duration  = arrival time + return time
      float new_duration=new_arrival+next->first->time2station;
      if(new_arrival>m_latency) break; //arrived after latency
      if(new_duration>this->m_battery+buffer) break; //out of battery
      //if(new_duration+m_charging>m_latency) break; //
      //cout<<"it->first->pos="<<it->first->pos<<endl;
      schedule.push_back(next->first->pos);
      schedule.duration=new_duration;
      it=next;
      next++;
    }//end while

    //cout<<"schedule.duration="<<schedule.duration<<" batter="<<m_battery<<endl;
    //given the schedule.duration determine how many chickens are needed
    //schedule.chicken_needed=(int)ceil(lcm( (int)(schedule.duration+m_charging), (int)m_latency)*1.0f/m_latency);
    schedule.insert(schedule.end(), it->first->path2station.rbegin(), it->first->path2station.rend() );
    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);

    //cout<<"schedule size="<<schedule.nodes.size()<<endl;
    return it;
}

//build a schedule from a single tour and its start
//add the schedule to "schedules"
//this method should probably combined with the other method.....
void
MyPCoverPlanner::build_valid_schedule_from_tsp
(const MyPCoverPlanner::TSP& tour,
 MyPCoverPlanner::TSP::const_iterator start,
 vector<MySchedule>& schedules)
{
    const int buffer=11;
    auto it=start; //the start of the schedule
    MySchedule schedule;
    float arrival=it->first->time2station; //arrival time

    //first station must be charging station
    if(it->first!=m_charging_station)
    {
      auto & path=it->first->path2station;
      schedule.insert(schedule.end(), path.begin(), path.end() );
      list<Node *> nodes=visitedNodes(path,0);
      //schedule.nodes.insert(nodes.begin(),nodes.end());
      schedule.nodes.insert(schedule.nodes.end(),nodes.begin(),nodes.end());
      schedule.nodes.push_back(it->first);
    }
    else
    {
      schedule.push_back(it->first->pos);
      //schedule.nodes.insert(it->first);
      schedule.nodes.push_back(it->first);
    }

    schedule.duration=it->first->time2station*2; //round trip
    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);
    auto next=it;
    next++;

    while( next!=tour.end() )
    {
      if(arrival!=schedule.duration-it->first->time2station)
      {
        cerr<<"! WRONG!!!! arrival="<<arrival<<" but="<<schedule.duration-it->first->time2station<<endl;
      }
      float new_arrival=arrival+it->second;
      float new_duration=new_arrival+next->first->time2station;
      if(new_arrival>m_latency) break; //arrived after latency
      if(new_duration>this->m_battery+buffer) break; //out of battery
      //if(new_duration+m_charging>m_latency) break; //

      int new_chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);
      if(new_chicken_needed>schedule.chicken_needed)
      {
        MySchedule tmp=schedule;
        //path back to the station
        auto path=it->first->path2station;
        tmp.insert(tmp.end(),path.rbegin(),path.rend());
        /*path.reverse();
        list<Node *> nodes=visitedNodes(path,arrival);
        tmp.nodes.insert(nodes.begin(),nodes.end());*/

        //schedules.push_back(tmp);

        //cout<<"schedule.chicken_needed="<<schedule.chicken_needed<<endl;
        schedule.chicken_needed=new_chicken_needed;
      }

      //cout<<"it->first->pos="<<it->first->pos<<endl;
      schedule.push_back(next->first->pos);
      //schedule.nodes.insert(next->first);
      schedule.nodes.push_back(next->first);
      schedule.duration=new_duration;
      arrival=new_arrival;
      it=next;
      next++;
    }//end while

    //cout<<"schedule.duration="<<schedule.duration<<" batter="<<m_battery<<endl;
    //given the schedule.duration determine how many chickens are needed
    //schedule.chicken_needed=(int)ceil(lcm( (int)(schedule.duration+m_charging), (int)m_latency)*1.0f/m_latency);
    auto path=it->first->path2station;
    //path.pop_front();
    schedule.insert(schedule.end(), path.rbegin(), path.rend() );
    path.reverse();
    list<Node *> nodes=visitedNodes(path,arrival);
    //schedule.nodes.insert(nodes.begin(),nodes.end());
    schedule.nodes.insert(schedule.nodes.end(),nodes.begin(),nodes.end());

    // {//clean up a bit
    //   set<Node*> tmp(schedule.nodes.begin(),schedule.nodes.end());
    //   schedule.nodes=list<Node*>(tmp.begin(),tmp.end());
    // }

    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);
    //cout<<"schedule.chicken_needed="<<schedule.chicken_needed<<endl;
    //cout<<"schedule size="<<schedule.nodes.size()<<endl;
    schedules.push_back(schedule);
    //cout<<"-------------------------"<<endl;
}


//collision between two
bool MyPCoverPlanner::collision_detection(const Point2d& pos1, const Point2d& pos2)
{
  Vector2d vec=(pos2-pos1);
  float dist=vec.norm();
  vec=vec/dist;
  for(int i=0;i<dist;i++)
  {
    Point2d pos=pos1+vec*i;
    if(collision_detection(pos)) return true;
  }
  return collision_detection(pos2);
}


//return true if m_agent collide with a non-movable object
//at a given location
bool MyPCoverPlanner::collision_detection(const Point2d& pos)
{
  //brute force collision detection
  Point2d pos_backup(m_agent->getX(),m_agent->getY());
  m_agent->tranlateTo(pos[0], pos[1]);
  bool collision=false;
  for(auto obst : m_scene->get_agents())
  {
    if( obst->is_movable() || obst==m_agent) continue;
    if( obst->collide(m_agent) )
    {
      collision=true;
      break;
    }
  }//end obst

  //move the agent back
  m_agent->tranlateTo(pos_backup[0], pos_backup[1]);
  return collision;
}

void MyPCoverPlanner::update() //update the timmer of the grid
{
  //cout<<"update"<<endl;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;
      n.t+=getMyGame()->getTimeStep(); //advanced this much
    }
  }

  //go through all agents to reset the timer
  //float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  //float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;
  for(auto agent : m_scene->get_agents())
  {
    if( !agent->is_movable() ) continue;
    Node * n=getNode(agent->getX(),agent->getY()); //&m_grid[(int)(agent->getY()/cell_h)][(int)(agent->getX()/cell_w)];
    n->t=0;
  }//end obst
}

void MyPCoverPlanner::
tsp_easy(vector<Node *>& subg, Node * start,
         vector<MyPCoverPlanner::TSP>& TSPs, int number)
{
  //build subset
  unordered_map<int, int> id2id;
  int vid=0;
  for(Node * node: subg)
  {
    int oldid=node->id;
    node->id=vid++;
    id2id[node->id]=oldid;
  }

  //now run tsp
  tsp(subg,start,TSPs, number);

  //restore the ids
  for(Node * node : subg)
  {
    node->id=id2id[node->id]; //put the old id back
  }
}

//note start must be in subg
void MyPCoverPlanner::
tsp(const vector<Node *>& subg, Node * start,
    vector<MyPCoverPlanner::TSP>& TSPs, int number)
{
  assert(find(subg.begin(),subg.end(),start)!=subg.end());
  auto TSP_FLAG=getFlag();

  //prepare the matrix
  int size=subg.size();
  if(size<4){
    cerr<<"! Error: TSP require graph with more than 3 nodes"<<endl;
    return;
  }
  int orig_flag=subg[0]->flag;
  for(int i=0;i<size;i++) subg[i]->flag=TSP_FLAG;

  int init_weight=(size<10)?9999:9999999; //somehow if the graph is too small, we can't use large weights...
  vector< vector< int >  > matrix = vector< vector< int >  >(size, vector< int >(size,init_weight));
  int edge_count=0;
  for(int i=0;i<size;i++)
  {
    const Node * n=subg[i];
    matrix[n->id][n->id]=0;

    for(auto& e : n->neighbors)
    {
      const Node * nei = e.first;
      if(nei->flag!=n->flag) continue;
      matrix[n->id][nei->id]=(int)e.second;
      matrix[nei->id][n->id]=(int)e.second;
      edge_count++;
    }//end nei
  }//end i

  //cout<<"edge_count="<<endl;

  //find tsp
  GraphTSP solver;
  vector<GraphTSP::TSPPath> paths;
  solver.FindTSPConcorde(matrix, paths, number);

  for(int i=0;i<paths.size();i++)
  {
    list< pair<Node *, float> > tsp;
    //cout<<"->";
    for(auto& n : paths[i])
    {
      //cout<<n.first<<", ";
      tsp.push_back(make_pair(subg[n.first],n.second));
    }
    //cout<<endl;
    assert(tsp.size()==subg.size());
    //make surea that the path starts at "start"
    while(tsp.front().first!=start)
    {
      tsp.push_back(tsp.front());
      tsp.pop_front();
    }
    TSPs.push_back(TSP(tsp.begin(),tsp.end()));
  }//end for i

  //reset flag
  for(int i=0;i<size;i++) subg[i]->flag=orig_flag;
}

void MyPCoverPlanner::
tsp(MyPCoverPlanner::Node * start,vector<MyPCoverPlanner::TSP>& TSPs, int number)
{
  vector<Node *> all_nodes;
  int id=0;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;
      n.id=id++;
      all_nodes.push_back(&n);
    }
  }

  return tsp(all_nodes,start,TSPs,number);
}

//generate constranits
void MyPCoverPlanner::generate_constraints( const vector<MySchedule>& schedules,  list<LP_constraints>& constraints)
{
  map< Node *, set<int> > node2schdules; //which schedules go through each node
  int size=schedules.size();
  for( int i=0;i<size;i++ )
  {
    const MySchedule & schedule=schedules[i];
    for(Node * node : schedule.nodes )
    {
      node2schdules[node].insert(i);
    }
  }//end for

  //create constraints for each node
  for(auto & cons : node2schdules)
  {
    LP_constraints lpc;
    lpc.vids=vector<int>(cons.second.begin(),cons.second.end());
    lpc.type=GLP_LO;
    lpc.lower_bound=1;
    constraints.push_back(lpc);
  }
}



//check if proposed_ts to conver all nodes in "nodes"
int MyPCoverPlanner::SolveLP
(list<Node *>& nodes, const vector<MyTimedSchedule>& proposed_ts, vector<MyTimedSchedule>& opt_ts)
{
  /*
  //build constraints
  list<LP_constraints> constraints;
  vector<float> solution; //0/1
  int total_chickens_needed=0;
  generate_constraints(schedules, constraints);

  if(this->m_num_valid_cells<=0)
  {
    cerr<<"! Error: Number of valid cells="
        <<this->m_num_valid_cells<<endl;
    exit(1);
  }

  if(m_num_valid_cells!=constraints.size())
  {
    cerr<<"! Error: LP constraint size inconsistent;"
        <<" expect "<<m_num_valid_cells<<", get "<<constraints.size()<<endl;
    exit(1);
  }

  //cout<<"constraints size="<<constraints.size()<<endl;
  //cout<<"schedules size="<<schedules.size()<<endl;
  if( SolveLP(schedules, constraints, solution) )
  {
    int size=solution.size();
    for(int i=0;i<size;i++){
      if(solution[i]!=0){
        opt.push_back(schedules[i]);
        total_chickens_needed+=schedules[i].chicken_needed;
      }
    }//end for i
  }
  else  //failed...no LP solved
    return -1;

  // cout<<"- Best schedule needs "<<total_chickens_needed
  //     <<" chickens and "<<m_schedules.size()<<" tours"<<endl;

  return total_chickens_needed;
  */
  return 0;
}


bool MyPCoverPlanner::SolveLP(
  vector<MySchedule>& schdules,
  list<LP_constraints>& constaints,
  vector<float>& solution)
{
	int constraint_size = constaints.size();
	int variable_size = schdules.size();

  cout<<"constraint_size="<<constraint_size<<" variable_size="<<variable_size<<endl;
  glp_term_out(GLP_OFF);

	glp_prob * lp = glp_create_prob();
	assert(lp);
	glp_set_prob_name(lp, "lp");
	glp_set_obj_dir(lp, GLP_MIN);
	glp_add_rows(lp, constraint_size);
	glp_add_cols(lp, variable_size);

	//init rows
	int iaja_size = 0;
	int row_id = 1;

	char tmp[64];
	for (auto & c : constaints)
	{
		sprintf(tmp, "r%08d", row_id);
		glp_set_row_name(lp, row_id, tmp);
		glp_set_row_bnds(lp, row_id, c.type, c.lower_bound, c.upper_bound);
		iaja_size += c.vids.size();
		row_id++;
	}

	//init cols
	for (int i = 1; i <= variable_size; i++)
	{
		char tmp[64];
		sprintf(tmp, "s%08d", i);
		glp_set_col_name(lp, i, tmp);
		//MIP
		glp_set_col_kind(lp, i, GLP_BV);
		//MIP
		{
			//auto & e = m->edges[i - 1];
			//const auto  & vec = m->vertices[e.vid[0]].p - m->vertices[e.vid[1]].p;
			glp_set_obj_coef(lp, i, schdules[i-1].chicken_needed);
		}

	}//end i

	//init ia, ja, and ar
	int * ia = new int[1 + iaja_size];
	int * ja = new int[1 + iaja_size];
	double * ar = new double[1 + iaja_size];
	assert(ia && ja && ar);

	int ia_id = 1;
	row_id = 1;
	for (auto & c : constaints)
	{
		for (auto vid : c.vids)
		{
			ia[ia_id] = row_id;
			ja[ia_id] = vid + 1;
			ar[ia_id] = 1;
			ia_id++;
		}//end for j

		row_id++;
	}//end for i


	glp_load_matrix(lp, iaja_size, ia, ja, ar);

	//assert(glp_simplex(lp, NULL) == 0);
	//assert(glp_get_status(lp) == GLP_OPT);

	glp_iocp parm;
	glp_init_iocp(&parm);
	parm.pp_tech = GLP_PP_ALL;
	parm.presolve = GLP_ON;
	parm.clq_cuts = GLP_ON;
	parm.binarize = GLP_ON;
	//parm.cb_func = callback;
	parm.cb_info = this;

	parm.tm_lim = 600000; //600 sec
	int err = glp_intopt(lp, &parm);
	//cout << "err=" << err << endl;

	double z = glp_mip_obj_val(lp);
	//cout << "objective value=" << z << endl;


	//get mip status
	int glp_prim_stat = glp_mip_status(lp);
/*
	switch (glp_prim_stat)
	{
  	case GLP_OPT: cout << "solution is optimal;" << endl; break;
  	case GLP_FEAS: cout << "solution is feasible;" << endl; break;
  	case GLP_INFEAS: cout << "solution is infeasible;" << endl; break;
  	case GLP_NOFEAS: cout << "problem has no feasible solution;" << endl; break;
  	case GLP_UNBND: cout << "problem has unbounded solution;" << endl; break;
  	case GLP_UNDEF: cout << "solution is undefined." << endl; break;
	}
*/
	bool solution_found = glp_prim_stat == GLP_OPT || glp_prim_stat == GLP_FEAS;

	if (solution_found)
	{
		for (int i = 1; i <= variable_size; i++)
		{
			double x = glp_mip_col_val(lp, i);
			solution.push_back(x);
		}
	}

	glp_delete_prob(lp);
	delete[] ia;
	delete[] ja;
	delete[] ar;

	return solution_found;
}

int MyPCoverPlanner::SolveLP(vector<MySchedule>& schedules, vector<MySchedule>& opt)
{
    //build constraints
    list<LP_constraints> constraints;
    vector<float> solution; //0/1
    int total_chickens_needed=0;
    generate_constraints(schedules, constraints);

    if(this->m_num_valid_cells<=0)
    {
      cerr<<"! Error: Number of valid cells="
          <<this->m_num_valid_cells<<endl;
      exit(1);
    }

    if(m_num_valid_cells!=constraints.size())
    {
      cerr<<"! Error: LP constraint size inconsistent;"
          <<" expect "<<m_num_valid_cells<<", get "<<constraints.size()<<endl;
      exit(1);
    }

    //cout<<"constraints size="<<constraints.size()<<endl;
    //cout<<"schedules size="<<schedules.size()<<endl;
    if( SolveLP(schedules, constraints, solution) )
    {
      int size=solution.size();
      for(int i=0;i<size;i++){
        if(solution[i]!=0){
          opt.push_back(schedules[i]);
          total_chickens_needed+=schedules[i].chicken_needed;
        }
      }//end for i
    }
    else  //failed...no LP solved
      return -1;

    // cout<<"- Best schedule needs "<<total_chickens_needed
    //     <<" chickens and "<<m_schedules.size()<<" tours"<<endl;

    return total_chickens_needed;
}

void MyPCoverPlanner::dijkstra(Node * root)
{
  vector<Node *> open;

  open.push_back(root);
  make_heap(open.begin(),open.end(), compareNode);
  root->parent=NULL;
  root->dist=0;

  while(open.empty()==false)
  {
    Node * n = open.front();
    pop_heap(open.begin(),open.end(), compareNode);
    open.pop_back();

    if(n->visited) continue; //already popped
    n->visited=true;

    for(auto& nei : n->neighbors)
    {
      Node * nn=nei.first;
      if(nn->visited) continue;
      float new_d=n->dist+nei.second;
      if(new_d<nn->dist)
      {
        bool fresh=(nn->parent==NULL && nn!=root);
        nn->dist=new_d;
        nn->parent=n;
        if(fresh){
          open.push_back(nn);
          push_heap(open.begin(),open.end(), compareNode);
        }
        else{
          make_heap(open.begin(),open.end(), compareNode);
        }
      }//end for nei
    }//end nei
  }//end while

}

void MyPCoverPlanner::get_desendents(Node * n, vector<Node*> & decendents)
{
  for(auto& nei : n->neighbors)
  {
    Node * nn=nei.first;
    if(nn->parent == n)
    {
      decendents.push_back(nn);
      get_desendents(nn,decendents);
    }
  }
}

//compute path from the charging station to each node in the graph
bool MyPCoverPlanner::paths2station()
{
  //brute force.... this can be done much more efficient
  this->m_num_valid_cells=0;
  m_charging_station->path2station.push_back(m_charging_station->pos);

  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      this->m_num_valid_cells++;

      if(&n==m_charging_station) continue;

      n.dist2station=m_agent->pathing(m_charging_station->pos, n.pos, n.path2station);
      n.time2station = dist2time(n.dist2station);
      if(n.time2station>m_latency){
        cerr<<"! Error: shortest time to station "<<n.id<<" ("<<n.time2station<<") is greater than the latency ("<<m_latency<<")"<<endl;
        return false;
      }
      if(n.time2station>m_battery/2){
        cerr<<"! Error: Insufficient battery power ("<<m_battery<<") to safely reach and return from some areas ("<<n.time2station<<")"<<endl;
        return false;
      }
    }
  }//end j

  return true;//everything looks good!
}

float MyPCoverPlanner::traceback
(MyPCoverPlanner::Node * n, list<MyPCoverPlanner::Node *>& path)
{
  auto ptr=n;
  float time_needed=0;
  while(ptr!=NULL)
  {
    if(!path.empty()) time_needed+=getWeight(ptr,path.front());
    path.push_front(ptr);
    ptr=ptr->parent;
  }
  return time_needed;
}

void MyPCoverPlanner::display()
{
  //draw nodes
  SDL_Rect box; //create a rect

  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;

      //draw node
      SDL_Renderer * renderer=getMyGame()->getRenderer();

      box.w=(int)(getMyGame()->getScreenWidth()*0.50f/m_width);
      box.h=(int)(getMyGame()->getScreenHeight()*0.50f/m_height);
      box.x = n.pos[0]-box.w/2;  //controls the rect's x coordinate
      box.y = n.pos[1]-box.h/2; // controls the rect's y coordinte

      if(n.b_charging_station){
        SDL_SetRenderDrawColor(renderer,0,250,0,0); //green
        SDL_RenderFillRect(renderer,&box);
      }
      else{
        SDL_SetRenderDrawBlendMode(renderer,SDL_BLENDMODE_BLEND);
        //cout<<m_latency<<endl;
        float s= std::min(1.0f, n.t*1.0f/m_latency);
        if(s<1) SDL_SetRenderDrawColor(renderer,200,0,0,s*s*255);
        else SDL_SetRenderDrawColor(renderer,0,0,0,255);
        SDL_RenderFillRect(renderer,&box);
        SDL_SetRenderDrawBlendMode(renderer,SDL_BLENDMODE_NONE);

        //SDL_SetRenderDrawColor(renderer,0,150,0,0);
        //SDL_RenderDrawRect(renderer,&box);
      }

      //draw the boundary
      box.w=(int)(getMyGame()->getScreenWidth()*0.9f/m_width);
      box.h=(int)(getMyGame()->getScreenHeight()*0.9f/m_height);
      box.x = n.pos[0]-box.w/2;  //controls the rect's x coordinate
      box.y = n.pos[1]-box.h/2; // controls the rect's y coordinte
      SDL_SetRenderDrawColor(renderer,50,50,100,0);
      SDL_RenderDrawRect(renderer,&box);

      //draw connections
      // for(auto & N : n.neighbors)
      // {
      //   Node * nei = N.first;
      //   if(n.id>nei->id) continue;
      //   // if(n.parent==nei || nei->parent==&n)
      //   //   SDL_SetRenderDrawColor(renderer,255,255,0,000);
      //   // else
      //     SDL_SetRenderDrawColor(renderer,100,100,100,000);
      //   SDL_RenderDrawLine(renderer, n.pos[0], n.pos[1], nei->pos[0], nei->pos[1]);
      // }
    }
  }

  //draw shortest paths to each node
  /*
  SDL_Renderer * renderer=getMyGame()->getRenderer();
  SDL_SetRenderDrawColor(renderer,0,0,200,100);
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;

      //draw path
      // auto & waypt=n.path2station.front();
      // SDL_RenderDrawLine(renderer, x, y, waypt[0], waypt[1]);
      for(auto i = n.path2station.begin();i!=n.path2station.end();i++)
      {
        auto j=i; j++;
        if(j==n.path2station.end()) continue;
        SDL_RenderDrawLine(renderer, (*i)[0], (*i)[1], (*j)[0], (*j)[1]);
      }//end i

    }
  }
  */
}

MyPCoverPlanner::Node * MyPCoverPlanner::getNode(float x, float y)
{
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;
  return &m_grid[(int)(y/cell_h)][(int)(x/cell_w)];
}

//collect nodes along the path that can be visited before the deadline
list<MyPCoverPlanner::Node *>
MyPCoverPlanner::visitedNodes(const list<Point2d>& path, float arrival_time)
{
  list<MyPCoverPlanner::Node *> nodes;
  Point2d pre=path.front();
  float travel_time=arrival_time;

  for(const Point2d& pos : path)
  {
    travel_time+=(pos-pre).norm();
    if(travel_time>this->m_latency) break; //visited after latency expires...
    Node * n = getNode(pos[0],pos[1]);
    pre=pos;
    if(!n->free) continue;
    if(nodes.empty()) nodes.push_back(n);
    else if(nodes.back()!=n) nodes.push_back(n);
  }
  return nodes;
}

//this version gets all visited nodes along the path regardless the latency constraint
inline list<MyPCoverPlanner::Node *>
MyPCoverPlanner::visitedNodes(const list<Point2d>& path)
{
  return visitedNodes(path, -FLT_MAX);
}

//
//
// Methods related timed schedule
//
//

//check if a node is pcoverd by the timed schedule (ts) with the schedules in
//n->timed_schedules
bool MyPCoverPlanner::is_pcovered
(MyPCoverPlanner::Node * n, MyPCoverPlanner::MyTimedSchedule * ts, double& witness)
{
  //this can be slow....

  vector< pair<double, MySchedule*> > timed_schedules=n->timed_schedules;
  {
    const unordered_map<Node *, double> & tt=ts->getTT();
    auto at=tt.at(n)+ts->start_time; //arrival time at node n on this schedule
    timed_schedules.push_back({at,ts});
  }

  //
  sort(timed_schedules.begin(),timed_schedules.end());

  //
  return is_pcovered(n,timed_schedules,witness);
}

//check if a node is pcoverd by the timed schedules in n->timed_schedules
//assume n->timed_schedules is sorted by arrival time
bool MyPCoverPlanner::is_pcovered(MyPCoverPlanner::Node * n, double& witness)
{
  return is_pcovered(n,n->timed_schedules, witness);
}

//check if a node is pcoverd by the provided timed schedules
//assume timed_schedules is sorted by arrival time
bool MyPCoverPlanner::is_pcovered
(MyPCoverPlanner::Node * n,
 vector< pair<double, MyPCoverPlanner::MySchedule*> >& timed_schedules,
 double& witness)
{
  auto it=n->timed_schedules.begin();
  auto next=it; next++;
  for(;next!=n->timed_schedules.end();next++)
  {
    double delta=next->first-it->first;
    if(delta>m_latency){
      witness=it->first+m_latency; //the first time latency constraint is violated
      return false;
    }
    it=next;
  }

  auto& ts1=timed_schedules.front();
  auto& tsn=n->timed_schedules.back();
  double delta=ts1.first + ts1.second->duration + m_charging - tsn.first;
  if(delta>m_latency){
    witness=m_latency+tsn.first; //the first time latency constraint is violated
    return false;
  }

  return true;
}

//build pcover for the given node
void MyPCoverPlanner::build_pcovers_from_timed_schedules
(MyPCoverPlanner::Node * n)
{
  cout<<"start to sort "<<n->timed_schedules.size()<<" timed schedules"<<endl;

  //sort by arrival time (not sure why this is so slow....)
  sort(n->timed_schedules.begin(),n->timed_schedules.end());
  typedef vector< pair<double,MySchedule*> >::iterator IT;
  typedef list<IT> IT_LIST;

  // cout<<"after sorting: ";
  // std::cout.precision(15);
  // int count=0;
  // for(auto& tmp : n->timed_schedules){
  //   cout<<"("<<tmp.first<<","<<tmp.second<<");";
  //   if(count++>10) break;
  // }
  // cout<<endl;

  cout<<"n "<<n->id<<" has "<<n->timed_schedules.size()<<" timed schedules and ";

  // cout<<"TS:";
  // for(auto it=n->timed_schedules.begin();it!=n->timed_schedules.end();it++)
  //   cout<<"("<<it->first<<", "<<it->second<<"); ";
  // cout<<endl;

  //go through each tour in the acsending order
  for(auto it=n->timed_schedules.begin();it!=n->timed_schedules.end();it++)
  {
    if(it->first>m_latency) break; //tour arriving the node too late
    IT_LIST valid_pcover;

    //add the tour as the first to arrive
    valid_pcover.push_back(it);
    if(! valid_node_pcover(valid_pcover) )
    {
      //find the next one that is as far as possible but less than latency
      auto last_valid=n->timed_schedules.end();
      auto next=it; next++;
      for(;next!=n->timed_schedules.end();next++)
      {
        auto last=valid_pcover.back();
        if(next->first-last->first<=m_latency)
        {
          last_valid=next;
          //if(next->first-last->first==m_latency)
          //  cout<<"HAHA "<<next->first<<"; "<<next->second<<endl;
        }
        //this tour is too late, but if there is a last_valid tour
        //remember it and then try again.
        else if(last_valid!=n->timed_schedules.end()){
          valid_pcover.push_back(last_valid);
          last_valid=n->timed_schedules.end();
          if(valid_node_pcover(valid_pcover)) break;
          else next--; //try again;
        }
      }//end for next

      //if last_valid is indeed valid, remember it
      if(last_valid!=n->timed_schedules.end())
      {
        valid_pcover.push_back(last_valid);
      }
    }//end if(! valid_node_pcover(valid_pcover) )

    //check if valid_pcover is indeed valid
    //cout<<"check if valid_pcover is indeed valid; valid_pcover size="<<valid_pcover.size()<<endl;
    if(valid_node_pcover(valid_pcover))
    {
      //cout<<"!valid!"<<endl;
      set<MySchedule*> tmp;
      for(auto entry : valid_pcover) tmp.insert(entry->second);
      Node::PCover pcover(tmp.begin(),tmp.end());

      //???? is the MyTimedSchedule* sorted? as set_diff requires sorted values
      sort(pcover.begin(), pcover.end());
/*
      if(pcover.size()==2 && pcover.front()==pcover.back())
      {
        cout<<"Haaaa n="<<n->id<<" ts size="<<n->timed_schedules.size()<<endl;
        for(auto ts : pcover)
          cout<<ts<<endl;
        cout<<"~~~~~~"<<endl;
        for(auto ts : n->timed_schedules)
          cout<<ts.first<<","<<ts.second<<endl;
        exit(1);
      }
  */


      ///check is pcover dominates an earlier pcover
      ///a pcover A dominates a second pcover B if A is a subset of B
      ///ie. A can pcover the node with just a subset of B
      bool dominated=false;;
      for(Node::PCover & o : n->valid_pcovers)
      {
          Node::PCover diff;
          set_difference(o.begin(),o.end(), pcover.begin(), pcover.end(), std::inserter(diff, diff.begin()));
          if(diff.empty()){ dominated=true; break; } //o is subset of pcover
      }

      //pcover is ignored if pcover is dominated.
      if(!dominated) //pcover is NOT domindate
      {
        //remove those dominiated by pcover
        list<Node::PCover> tmp;
        for(Node::PCover & o : n->valid_pcovers)
        {
            if(o.size()<pcover.size()){ tmp.push_back(o); continue; } //pcover cannot dominate o if o has fewer schedules
            Node::PCover diff;
            set_difference(pcover.begin(), pcover.end(), o.begin(),o.end(), std::inserter(diff, diff.begin()));
            if(!diff.empty()){ tmp.push_back(o); }
        }
        tmp.push_back(pcover);
        n->valid_pcovers.swap(tmp);
      }

    }//end if

  }//end for auto it


  cout<<n->valid_pcovers.size()<<" pcovers"<<endl;
  //exit(1);
}

//find the optimal subset of timed schdules from node pcovers
int MyPCoverPlanner::SolveLP(vector<MyTimedSchedule>& opt)
{
  //build a list of Node::PCover for each node
  unordered_map<MySchedule *, int> timed_schedules;  //variables #1
  map<Node::PCover, int> node_pcovers;  //variables #2
  list<Node *> nodes;

  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      build_pcovers_from_timed_schedules(&n);
      nodes.push_back(&n);
      for(auto& pc: n.valid_pcovers)
      {
        //cout<<"\tpc size="<<pc.size()<<";";
        node_pcovers.insert(make_pair(pc, 0));
        //collect all timed_schedules
        for(auto & s : pc){
          timed_schedules.insert(make_pair(s,0));
          //cout<<s<<";";
        }
        //cout<<endl;
      }
    }//end for j
  }//end for i
  int ts_size = timed_schedules.size();
  int schedule_id=0;
  for(auto & ts : timed_schedules) ts.second=schedule_id++;

  int pcover_id=ts_size;
  for(auto & pc : node_pcovers) pc.second=pcover_id++;

  //the goal is to select a subset of timed_schedules
  list<LP_constraints> constraints;
  vector<float> solution; //0/1
  int total_chickens_needed=0;
  //create constraints, type 1
  //make sure that every nodeis covered at least once
  for(Node * n : nodes)
  {
    LP_constraints lpc;
    for(auto& pc: n->valid_pcovers)
    {
      lpc.vids.push_back(node_pcovers[pc]);
    }
    lpc.type=GLP_LO;
    lpc.lower_bound=1;
    constraints.push_back(lpc);
  }//end n

  //create constraints, type 2
  //make sure that a node-pcover is selected only when its timed
  //schedules are all selected
  for(auto & i : node_pcovers)
  {
    LP_constraints lpc;
    const Node::PCover & pc=i.first;
    int pc_id=i.second;
    for(MySchedule * ts: pc){
      lpc.vids.push_back(timed_schedules[ts]);
      lpc.coeffs.push_back(1);
    }//end ts
    lpc.vids.push_back(pc_id);
    lpc.coeffs.push_back(-((int)pc.size()));
    lpc.type=GLP_LO;
    lpc.lower_bound=0;
    constraints.push_back(lpc);
  }//end i

  //now setup LP....
  int constraint_size = constraints.size();
	int variable_size = timed_schedules.size() + node_pcovers.size();


  cout<<"constraint_size="<<constraint_size<<" variable_size="<<variable_size<<endl;

  //glp_term_out(GLP_OFF);

	glp_prob * lp = glp_create_prob();
	assert(lp);
	glp_set_prob_name(lp, "lp");
	glp_set_obj_dir(lp, GLP_MIN);
	glp_add_rows(lp, constraint_size);
	glp_add_cols(lp, variable_size);

	//init rows (constraints)
	int iaja_size = 0;
	int row_id = 1;

	char tmp[64];
	for (auto & c : constraints)
	{
		sprintf(tmp, "r%08d", row_id);
		glp_set_row_name(lp, row_id, tmp);
		glp_set_row_bnds(lp, row_id, c.type, c.lower_bound, c.upper_bound);
		iaja_size += c.vids.size();
		row_id++;
	}

	//init cols (varibles)
  //first set: timed_schedules
	for (int i = 1; i <= variable_size; i++)
	{
		char tmp[64];
		sprintf(tmp, "s%08d", i);
		glp_set_col_name(lp, i, tmp);
		//MIP
		glp_set_col_kind(lp, i, GLP_BV);
		//MIP
		glp_set_obj_coef(lp, i, (i<=ts_size)?1:0 );
	}//end i

	//init ia, ja, and ar
	int * ia = new int[1 + iaja_size];
	int * ja = new int[1 + iaja_size];
	double * ar = new double[1 + iaja_size];
	assert(ia && ja && ar);

	int ia_id = 1;
	row_id = 1;
	for (auto & c : constraints)
	{
    auto coeffs_it = c.coeffs.begin();
    //check if we have sufficient number of coefficients
    if(c.coeffs.empty()==false)
      assert(c.coeffs.size()==c.vids.size());
    //now create constraints
		for (auto vid : c.vids)
		{
			ia[ia_id] = row_id;
			ja[ia_id] = vid + 1;
      if(c.coeffs.empty()) ar[ia_id] = 1;
      else{
        ar[ia_id] = *coeffs_it;
        coeffs_it++;
      }
      //cout<<"ia["<<ia_id<<"]="<<ia[ia_id]<<" ja["<<ia_id<<"]="<<ja[ia_id]<<" ar["<<ia_id<<"]="<<ar[ia_id]<<endl;
			ia_id++;
		}//end for j

		row_id++;
	}//end for i


	glp_load_matrix(lp, iaja_size, ia, ja, ar);

	//assert(glp_simplex(lp, NULL) == 0);
	//assert(glp_get_status(lp) == GLP_OPT);

	glp_iocp parm;
	glp_init_iocp(&parm);
	parm.pp_tech = GLP_PP_ALL;
	parm.presolve = GLP_ON;
	parm.clq_cuts = GLP_ON;
	parm.binarize = GLP_ON;
	//parm.cb_func = callback;
	parm.cb_info = this;

	parm.tm_lim = 18000000; //1800 sec
	int err = glp_intopt(lp, &parm);
	//cout << "err=" << err << endl;

	double z = glp_mip_obj_val(lp);
	//cout << "objective value=" << z << endl;


	//get mip status
	int glp_prim_stat = glp_mip_status(lp);

	switch (glp_prim_stat)
	{
  	case GLP_OPT: cout << "solution is optimal;" << endl; break;
  	case GLP_FEAS: cout << "solution is feasible;" << endl; break;
  	case GLP_INFEAS: cout << "solution is infeasible;" << endl; break;
  	case GLP_NOFEAS: cout << "problem has no feasible solution;" << endl; break;
  	case GLP_UNBND: cout << "problem has unbounded solution;" << endl; break;
  	case GLP_UNDEF: cout << "solution is undefined." << endl; break;
	}

	bool solution_found = glp_prim_stat == GLP_OPT || glp_prim_stat == GLP_FEAS;

	if (solution_found)
	{
    vector<MySchedule*> timed_schedules_vector; //linearized version of timed_schedules
    timed_schedules_vector.resize(ts_size);
    for(auto& ts : timed_schedules)
      timed_schedules_vector[ts.second]=ts.first;

		for (int i = 1; i <= ts_size; i++)
		{
			double x = glp_mip_col_val(lp, i);
      if(x!=0)
			   opt.push_back(*timed_schedules_vector[i-1]);
		}
	}

	glp_delete_prob(lp);
	delete[] ia;
	delete[] ja;
	delete[] ar;

	return opt.size();
}

void
MyPCoverPlanner::schedule2timedschedules
(MyPCoverPlanner::MySchedule & base, vector<MyPCoverPlanner::MyTimedSchedule>& Tschedules)
{
    //vector<MyTimedSchedule> result;
    MyTimedSchedule schedule(base);

    int chicken_needed=schedule.chicken_needed;
    schedule.chicken_needed=1;
    double cur_time=drand48()*0.01;
    schedule.start_time=cur_time;

    cout<<"schedule.start_time="<<schedule.start_time<<endl;
    Node * pre=NULL;

    //create the first timed schedule
    list<Node *> no_repeats;
    for(Node * n : schedule.nodes)
    {
      if(pre==n) continue;
      if(pre!=NULL){
        float w=getWeight_no_exit(pre, n);
        if(w==-FLT_MAX){
          w=dist2time( (pre->pos-n->pos).norm() );
        }
        cur_time+=w;
      }
      no_repeats.push_back(n);
      schedule.arrival_times.push_back(cur_time);
      pre=n;
    }
    schedule.nodes.swap(no_repeats);
    Tschedules.push_back(schedule);

    //create the rest of timed schedules offset by the latency
    for(int i=1;i<=chicken_needed;i++)
    {
      schedule.start_time+=m_latency;
      list<double> arrival_times;
      for(double t : schedule.arrival_times)
          arrival_times.push_back(t+m_latency);
      schedule.arrival_times.swap(arrival_times);
      Tschedules.push_back(schedule);
    }
    //done
}

//get travel time from the charging station
const unordered_map<MyPCoverPlanner::Node *, double> &
MyPCoverPlanner::MyTimedSchedule::getTT()
{
  if(node2tt.empty()){
    auto atime=this->arrival_times.begin(); //travel time from the charging station along this tour
    for(Node * node : this->nodes)
    {
      node2tt[node]=*atime;
      atime++;
    }
  }
  return node2tt;
}

//a simple helper methods that check if a node pcover
//(in the form of iterators) is valid
bool MyPCoverPlanner::valid_node_pcover
(list<vector< pair<double,MyPCoverPlanner::MySchedule*> >::iterator> & pcover)
{
  auto first_uav=pcover.front();
  auto last_uav=pcover.back();
  float time_diff=first_uav->first+first_uav->second->duration+m_charging-last_uav->first;
  //cout<<"time diff="<<time_diff<<" m_latency="<<m_latency<<endl;
  //first uav will come after m_lattency time units
  return time_diff<=m_latency;
}


//given a node and the required arrival time interval (arrive_low, arrive_hi)
//where arrive_low<=arrive_hi, update this->start_interval if possible
//return true if start_interval is updated
bool MyPCoverPlanner::MyFlexibleTimedSchedule::update_start_interval
(Node * n, double arrive_low, double arrive_hi)
{
  double time2n=this->node_2_arrival_times[n]; //time needed to arrive n
  double s=0,e=arrive_hi-time2n; //s: earliest start time, e: latest start time
  if(time2n<arrive_low) s=arrive_low-time2n;
  if(s+time2n>arrive_hi) return false; //cannot arrive before arrive_hi
  if(e<s) return false; //this cannot be achieved

  //(s,e) is the departure time interval for this schedule
  //check if it overlaps with the current schedule
  MyInterval new_start = this->start_interval.intersect(MyInterval(s,e));

  if(!new_start.valid()) return false;
  this->start_interval=new_start;
  // if(e<this->start_interval.s) return false; //not overlap
  // if(s>this->start_interval.e) return false; //not overlap
  //
  // this->start_interval.s=max(s, this->start_interval.s);
  // this->start_interval.e=min(e, this->start_interval.e);

  return true;
}

//update start interval using all nodes in this schedule
void MyPCoverPlanner::MyFlexibleTimedSchedule::update_start_interval
(double arrive_low, double arrive_hi)
{
  for(Node * n : nodes){
    if(!update_start_interval(n,arrive_low,arrive_hi)) break;
  }
}

//can this schedule cover the given node between the given times (arrive_low, arrive_hi)
//this also considers the needed charging time
bool MyPCoverPlanner::MyFlexibleTimedSchedule::is_covered
(Node * n, double arrive_low, double arrive_hi, double charging)
{
  double time2n=this->node_2_arrival_times[n]; //time needed to arrive n
  double s=0,e=arrive_hi-time2n; //s: earliest start time, e: latest start time
  if(time2n<arrive_low) s=arrive_low-time2n;
  if(s+time2n>arrive_hi) return false; //cannot arrive before arrive_hi
  if(e<s) return false; //this cannot be achieved

  //now we must start between (s,e) to arrive the node on time
  //check if we can do so
  double E=this->start_interval.e;
  while(E<s) E+=(this->duration+charging);
  //E+=(this->duration+charging); //this is the first time (S,E) may overlap with (s,e)
  double S=E-this->start_interval.e+this->start_interval.s;

  while(S<e){
    if(S>=s) return true;
    S+=(this->duration+charging);
  }
  return false;
}

}//end namespace GMUCS425
