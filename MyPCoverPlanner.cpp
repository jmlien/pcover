#include "MyPCoverPlanner.h"
#include "MyGame.h"
#include "MyDragonAgent.h"
#include "tsp/GraphTSP.h"
#include <algorithm>
#include "glpk/glpk.h" //linear programming solver
#include <map>

using namespace mathtool;

namespace GMUCS425
{

int gcd(int a, int b)
{
    for (;;)
    {
        if (a == 0) return b;
        b %= a;
        if (b == 0) return a;
        a %= b;
    }
    return 0;
}

int lcm(int a, int b)
{
    int temp = gcd(a, b);
    return temp ? (a / temp * b) : 0;
}

float MyPCoverPlanner::dist2time(float dist)
{
  return (float)ceil(dist*5);//distance * 5 = time to travel
}

//estimate the cost of travelling from pos1 to pos2
//scaled using the values generated by Perlin noise
float MyPCoverPlanner::cost(const Point2d& pos1, const Point2d& pos2)
{
  return dist2time((pos1-pos2).norm());

  const Uint32 * terrain = m_scene->get_terrain();
  int terrain_width = getMyGame()->getScreenWidth();
  int terrain_height = getMyGame()->getScreenHeight();
  Point2d mid( (pos1[0]+pos2[0])/2, (pos1[1]+pos2[1])/2 );
  Uint32 watery=terrain[((int)mid[1])*terrain_width+((int)mid[0])] & 255;
  float scale=sqrt(sqrt(watery*1.0f/255)); //0~1
  return (1+scale) * (pos1-pos2).norm();
}

//------------
bool MyPCoverPlanner::build() //build a grid or graph
{
  if(!m_grid.empty()) return false; //build only if the grid is empty

  m_grid=std::vector< std::vector<Node> >( m_height, std::vector<Node>(m_width,Node()) );
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  //TODO: go through the nodes, and init the data for each node
  int nid=0;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      n.id=nid++;
      n.pos.set( cell_w*(j+0.5f), cell_h*(i+0.5f) );
      //check if the node is free of collision
      n.free = !collision_detection(n.pos);
      //cout<<"node ("<<j<<","<<i<<") is free="<<n.free<<endl;
    }//end j
  }//end i

  //Make connections
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      //connect the neighboring cells
      for(int dx=-1;dx<2;dx++)
      {
        int nj=j+dx;
        if(nj<0 || nj>=m_width) continue;
        for(int dy=-1;dy<2;dy++)
        {
          int ni=i+dy;
          if(ni<0 || ni>=m_height) continue;
          Node & nei = m_grid[ni][nj];
          if(&nei==&n) continue; //the node itself

          if(collision_detection(n.pos, nei.pos)) continue; //not passable
          float dist=cost(n.pos, nei.pos);
          if(nei.free) n.neighbors.push_back( make_pair(&nei,dist));
        }//end for dy
      }//end for dx
      //cout<<"n has "<<n.neighbors.size()<<" neis"<<endl;
    }//end j
  }//end i

  return true;
}

// //check if the schedule with the new duration would be valid
// bool MyPCoverPlanner::isvalid(MySchedule& s, Node * new_n)
// {
//   if(new_duration>this->m_battery+10) return false;
//   if(new_duration>this->)
// }

//schedule
bool MyPCoverPlanner::schedule( const Point2d& start )
{
  m_schedules.clear();

  //check if the start is valid (i.e., inside the screen)
  if(start[0]<0 || start[1]>=getMyGame()->getScreenWidth()) return false;

  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  Node * S=&m_grid[(int)(start[1]/cell_h)][(int)(start[0]/cell_w)];
  if(m_charging_station!=NULL) m_charging_station->b_charging_station=false;
  S->b_charging_station = true;
  m_charging_station=S;

  //compute path to charging station
  cout<<"- Compute all paths from charging station"<<endl;
  m_num_valid_cells=-1;
  if( paths2station()==false ) return false;

  //build dijkstra tree
  dijkstra(m_charging_station);

  //schedule!
  if(m_opt_method=="tsp_greedy")
    schedule_tsp_segments_greedy(20);
  else if(m_opt_method=="tsp_lp")
    schedule_tsp_segments_lp(20);
  else if(m_opt_method=="tsp_lp2")
    schedule_tsp_segments_lp2(20);
  else if(m_opt_method=="shortest_lp")
    schedule_shorest_paths_lp();
  else if(m_opt_method=="lollipop_lp")
      schedule_lollipop_lp();
  else{
    cerr<<"! Error: Unknown pcover optimization method: "<<m_opt_method<<endl;
    return false;
  }

  //
  return true;
}

void MyPCoverPlanner::schedule_shorest_paths_lp()
{
  vector<MySchedule> schedules;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      //cout<<"n id="<<n.id<<" time to station="<<n.time2station<<endl;
      MySchedule schedule;
      const auto & path=n.path2station;
      schedule.insert(schedule.end(), path.begin(), path.end() );
      schedule.insert(schedule.end(), path.rbegin(), path.rend() );
      schedule.nodes=visitedNodes(schedule,0);

      // cout<<"nodes:";
      // for(auto n : schedule.nodes) cout<<n->id<<",";
      // cout<<endl;

      //schedule.nodes.push_back(&n);
      schedule.duration=n.time2station*2;

      schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);

      // cout<<"schedule.chicken_needed="<<schedule.chicken_needed<<endl;
      // cout<<"schedule size="<<schedule.nodes.size()<<endl;

      schedules.push_back(schedule);
    }
  }

  //find optimal subset
  int total_chickens_needed=SolveLP(schedules, m_schedules);
  cout<<"- Best schedule needs "<<total_chickens_needed<<" chickens and "<<m_schedules.size()<<" tours"<<endl;
}

bool MyPCoverPlanner::schedule_tsp_segments_lp(int trials)
{
  //
  vector<TSP> tours;
  tsp(m_charging_station,tours,trials);
  //assert(tour.front().first==m_charging_station);

  int best_tour=0;
  int min_chickens_needed=INT_MAX;
  vector<MySchedule> best_m_schedules;

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    //int total_chickens_needed=0;
    vector<MySchedule> schedules;
    m_schedules.clear();

    //break TSP into segments
    for(auto it=tour.begin(); it!=tour.end(); it++)
    {
        //MySchedule schedule;
        build_valid_schedule_from_tsp(tour, it, schedules);
        //cout<<"schedules.size()="<<schedules.size()<<endl;
        //schedules.push_back(schedule);
    }//end for tour

    //build constraints
    /*
    list<LP_constraints> constraints;
    vector<float> solution; //0/1
    int total_chickens_needed=0;
    generate_constraints(schedules, constraints);

    if(tour.size()!=constraints.size())
    {
      cerr<<"! Error: LP constraint size inconsistent"<<endl;
      exit(1);
    }

    //cout<<"constraints size="<<constraints.size()<<endl;
    if( SolveLP(schedules, constraints, solution) )
    {
      int size=solution.size();
      //cout<<"solution=";
      for(int i=0;i<size;i++){
        if(solution[i]>0.5){
          //cout<<i<<",";
          m_schedules.push_back(schedules[i]);
          total_chickens_needed+=schedules[i].chicken_needed;
        }
      }//end for i
      //cout<<endl;
    }
    else continue;
    */
    int total_chickens_needed=SolveLP(schedules,m_schedules);
    //check if this schedule is better
    cout<<"trial #"<<i<<" needs "<<total_chickens_needed<<" chickens"<<endl;
    if(total_chickens_needed<min_chickens_needed)
    {
      min_chickens_needed=total_chickens_needed;
      best_m_schedules=m_schedules;
    }

  }//end for i

  //failed...no LP solved
  if(min_chickens_needed==INT_MAX) return false;

  cout<<"- Best schedule needs "<<min_chickens_needed<<" chickens and "<<best_m_schedules.size()<<" tours"<<endl;
  m_schedules=best_m_schedules;
  return true;

}//end MyPCoverPlanner

bool MyPCoverPlanner::schedule_tsp_segments_lp2(int trials)
{
  //
  vector<TSP> tours;
  tsp(m_charging_station,tours,trials);
  vector<MySchedule> schedules;

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    //break TSP into segments
    for(auto it=tour.begin(); it!=tour.end(); it++)
    {
        build_valid_schedule_from_tsp(tour, it, schedules);
    }//end for tour
  }


  //build constraints
  /*
  list<LP_constraints> constraints;
  vector<float> solution; //0/1
  int total_chickens_needed=0;
  generate_constraints(schedules, constraints);
  if(tours.front().size()!=constraints.size())
  {
    cerr<<"! Error: LP constraint size inconsistent"<<endl;
    exit(1);
  }

  //cout<<"constraints size="<<constraints.size()<<endl;
  //cout<<"schedules size="<<schedules.size()<<endl;
  if( SolveLP(schedules, constraints, solution) )
  {
    int size=solution.size();
    for(int i=0;i<size;i++){
      if(solution[i]!=0){
        m_schedules.push_back(schedules[i]);
        total_chickens_needed+=schedules[i].chicken_needed;
      }
    }//end for i
  }
  else  //failed...no LP solved
    return false;
  */

  int total_chickens_needed=SolveLP(schedules,m_schedules);

  cout<<"- Best schedule needs "<<total_chickens_needed
      <<" chickens and "<<m_schedules.size()<<" tours"<<endl;

  return true;
}//end MyPCoverPlanner


void MyPCoverPlanner::schedule_tsp_segments_greedy(int trials)
{
  //
  vector<TSP> tours;
  tsp(m_charging_station,tours,trials);
  //assert(tour.front().first==m_charging_station);

  int best_tour=0;
  int min_chickens_needed=INT_MAX;
  vector<MySchedule> best_m_schedules;

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    int total_chickens_needed=0;
    m_schedules.clear();
    //break TSP into segments
    for(TSP::const_iterator it=tour.begin(); it!=tour.end(); it++)
    {
      MySchedule schedule;
      it=build_valid_schedule_from_tsp(tour, it, schedule);
      total_chickens_needed+=schedule.chicken_needed;
      m_schedules.push_back(schedule);
      // cout<<"schedule=";
      // for(Node * n : schedule.nodes)
      // {
      //   cout<<n->id<<"->";
      // }
      // cout<<" cost="<<schedule.chicken_needed<<endl;
    }//end for tour

    cout<<"trial #"<<i<<" needs "<<total_chickens_needed<<" chickens"<<endl;
    if(total_chickens_needed<min_chickens_needed)
    {
      min_chickens_needed=total_chickens_needed;
      best_m_schedules=m_schedules;
    }
  }//end for i trials

  cout<<"- Best schedule needs "<<min_chickens_needed<<" chickens and "<<best_m_schedules.size()<<" tours"<<endl;
  m_schedules=best_m_schedules;
}

//lollipop tours
void MyPCoverPlanner::schedule_lollipop_lp()
{
  //for each node, create a lollipop
  vector<MySchedule> schedules;
  cout<<"root id="<<m_charging_station->id<<endl;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors

      //
      //if(&n!=this->m_charging_station) continue;
      //if(n.id!=77) continue;
      //

      MySchedule schedule;

      cout<<"processing id="<<n.id<<endl;

      //path to node n
      auto path=n.path2station;
      schedule.insert(schedule.end(), path.begin(), path.end() );
      schedule.nodes=visitedNodes(schedule,0);

      //the loop
      list<Node*> lollipop;
      float time_need=buid_lollipop(&n,lollipop);
      cout<<"buid_lollipop time_need="<<time_need<<endl;

      for(Node * n : lollipop)
      {
        schedule.push_back(n->pos);
        schedule.nodes.push_back(n);
      }

      //return trip
      schedule.insert(schedule.end(), path.rbegin(), path.rend() );
      path.reverse();
      auto return_nodes=visitedNodes(path,time_need+n.time2station);
      schedule.nodes.insert(schedule.nodes.end(),return_nodes.begin(),return_nodes.end());

      // cout<<"nodes:";
      // for(auto n : schedule.nodes) cout<<n->id<<",";
      // cout<<endl;

      //schedule.nodes.push_back(&n);
      schedule.duration=n.time2station*2+time_need;
      schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);

      // cout<<"schedule.chicken_needed="<<schedule.chicken_needed<<endl;
      // cout<<"schedule size="<<schedule.nodes.size()<<endl;

      schedules.push_back(schedule);
    }
  }

  // m_schedules=schedules;
  // return;

  //find optimal subset
  int total_chickens_needed=SolveLP(schedules, m_schedules);
  cout<<"- Best schedule needs "<<total_chickens_needed<<" chickens and "<<m_schedules.size()<<" tours"<<endl;
}

//build a lollipop tour and return the time needed
float MyPCoverPlanner::buid_lollipop
(MyPCoverPlanner::Node * n, list<Node*>& lollipop_nodes)
{
  float battery=this->m_battery-n->time2station*2;
  float latency=this->m_latency-n->time2station;
  if(battery<=0 || latency<=0) return 0;//no time/power left

  cout<<"battery="<<battery<<endl;
  cout<<"latency="<<latency<<endl;

  //init the process with a simple loop
  Lollipop lollipop=init_lollipop(n,battery,latency);
  if(lollipop.head==NULL) return 0;

  //now expand the loop
  //int count=0;
  while(true)
  {
    if(!expand_lollipop(lollipop,battery,latency))
    {
      if(!reduce_lollipop(lollipop,battery,latency)) break;
    }
  }
  // {
  //   if(count++==2) break;
  // }

  cout<<"--------"<<endl;

  //collect nodes
  auto ptr=lollipop.head;
  do{
    lollipop_nodes.push_back(ptr->data);
    ptr=ptr->next;
  }
  while(ptr!=lollipop.head);

  cout<<"lollipop count="<<lollipop.count<<endl;

  return lollipop.time_needed;
}

MyPCoverPlanner::Lollipop MyPCoverPlanner::init_lollipop
(MyPCoverPlanner::Node * n, float battery, float latency)
{
  Lollipop lollipop;
  n->flag=n->id;
  Lollipop_Node * ln0=new Lollipop_Node(n);
  assert(ln0);
  lollipop.insert(ln0);

  //get the second node
  pair<Node *, float> n2=getClosestFurtherNodes(n);

  if(n2.first==NULL) return lollipop;
  if(n2.second > battery || n2.second>latency) return lollipop;
  n2.first->flag=n->id;
  Lollipop_Node * ln1=new Lollipop_Node(n2.first);
  assert(ln1);
  ln1->pre=ln0; ln1->next=ln0;
  ln1->pre_cost=n2.second;
  ln1->next_cost=n2.second;
  lollipop.insert(ln1);

  //try to get the 3rd node
  pair< Node *, pair<float,float> > n3=getClosestCommonNeighbor(n,n2.first);

  if(n3.first==NULL) return lollipop;
  n3.first->flag=n->id;

  float total_cost=n2.second+n3.second.second+n3.second.first;
  if(total_cost > battery || total_cost>latency) return lollipop;

  //now we have 3 nodes, create a loop
  Lollipop_Node * ln2=new Lollipop_Node(n3.first);
  assert(ln2);
  ln2->pre=ln1; ln2->next=ln0;
  ln2->pre_cost=n3.second.second;
  ln2->next_cost=n3.second.first;
  lollipop.insert(ln2);

  return lollipop;
}

bool MyPCoverPlanner::expand_lollipop
(MyPCoverPlanner::Lollipop & lollipop, float battery, float latency)
{
  //for each consecutive pair
  auto * ptr=lollipop.head;
  auto * next=ptr->next;
  float min_cost_increase=FLT_MAX;
  float min_dist=FLT_MAX;
  Lollipop_Node * best=new Lollipop_Node();

//cout<<"expand_lollipop next="<<next<<" head="<<lollipop.head<<endl;

  //while(next!=lollipop.head)
  do
  {
    //pair< Node *, pair<float,float> > n
    auto n=getClosestCommonNeighbor(ptr->data,next->data);
    if(n.first!=NULL){
      float increase=n.second.first+n.second.second-ptr->next_cost;
      cout<<"\t add node "<<n.first->id<<" increase="<<increase<<endl;
      if(increase<min_cost_increase ||
         (min_cost_increase==increase && n.first->dist>min_dist))
      {
        min_cost_increase=increase;
        min_dist=n.first->dist;
        best->data=n.first;
        best->pre=ptr;
        best->next=next;
        best->pre_cost=n.second.first;
        best->next_cost=n.second.second;
      }
    }

    ptr=next;
    next=ptr->next;
  }while(ptr!=lollipop.head); //end while

  //
  if(best->data==NULL) return false; //failed

  float new_cost=lollipop.time_needed + min_cost_increase;
  //cout<<"new_cost="<<new_cost<<" min_cost_increase="<<min_cost_increase<<endl;
  if(new_cost> battery) return false; //exceeded needed power
  if(new_cost > latency) return false; //exceeded time

  best->data->flag=lollipop.head->data->id;
  lollipop.insert(best);

  cout<<"expand ->"<<best->data->id<<" time need="<<lollipop.time_needed<<endl;
  return true;
}

//convert the lollipop to a graph and find TSP
bool MyPCoverPlanner::reduce_lollipop(MyPCoverPlanner::Lollipop & lollipop, float battery, float latency)
{
  if(lollipop.count<=3) return false; //too small
  //return false;
  //build subset
  cout<<"build subset"<<endl;
  vector<Node*> subg;
  unordered_map<int, int> id2id;
  auto ptr=lollipop.head;
  int vid=0;
  do{
    Node * node=ptr->data;
    int oldid=node->id;
    node->id=vid++;
    id2id[node->id]=oldid;
    subg.push_back(node);
    ptr=ptr->next;
  }
  while(ptr!=lollipop.head);

  //get tsp
  cout<<"run tsp"<<endl;
  vector<MyPCoverPlanner::TSP> TSPs;
  tsp(subg, lollipop.head->data,TSPs, 1);
  if(TSPs.empty()) return false;
  //cout<<"TSPs size="<<TSPs.size()<<endl;

  //compute cost
  cout<<"get tsp cost"<<endl;
  MyPCoverPlanner::TSP & TSP=TSPs.front();
  //cout<<"TSP size="<<TSP.size()<<endl;
  float time_needed=0;
  for(auto & node : TSP)
  {
    node.first->id=id2id[node.first->id]; //put the old id back
    time_needed+=node.second;
  }
  cout<<"tsp time_needed="<<time_needed<<" old time="<<lollipop.time_needed<<endl;
  //if(time_needed>=lollipop.time_needed) //not faster...
  //  return false;

  //convert tsp to lollipop
  cout<<"convert tsp to lollipop"<<endl;
  lollipop.reset();
  Lollipop_Node * n0=new Lollipop_Node(TSP.front().first);
  assert(n0);
  lollipop.insert(n0);
  Lollipop_Node * pre=n0;
  auto pre_it=TSP.begin();

  lollipop.count=TSP.size();
  lollipop.time_needed=time_needed;
  for( auto it=++TSP.begin(); it!=TSP.end(); it++)
  {
    Lollipop_Node * n=new Lollipop_Node(it->first);
    assert(n);
    pre->next=n; n->pre=pre;
    pre->next_cost=n->pre_cost=pre_it->second;
    pre=n;
    pre_it=it;
  }//end for node
  //now, pre, is the last node
  pre->next=n0; n0->pre=pre;
  pre->next_cost=n0->pre_cost=TSP.back().second;

  return expand_lollipop(lollipop,battery,latency);
}

MyPCoverPlanner::TSP::const_iterator
MyPCoverPlanner::build_valid_schedule_from_tsp
(const MyPCoverPlanner::TSP& tour,
 MyPCoverPlanner::TSP::const_iterator start,
 MySchedule& schedule)
{
    auto it=start; //the start of the schedule
    //first station must be charging station
    if(it->first!=m_charging_station)
    {
      schedule.insert(schedule.end(), it->first->path2station.begin(), it->first->path2station.end() );
    }
    else
    {
      schedule.push_back(it->first->pos);
    }

    schedule.duration=it->first->time2station*2; //round trip
    auto next=it;
    next++;

    while( next!=tour.end() )
    {
      //schedule.nodes.insert(it->first);
      schedule.nodes.push_back(it->first);
      float new_arrival=schedule.duration-it->first->time2station+it->second;
      float new_duration=new_arrival+next->first->time2station;
      if(new_arrival>m_latency) break; //arrived after latency
      if(new_duration>this->m_battery+11) break; //out of battery
      //if(new_duration+m_charging>m_latency) break; //
      //cout<<"it->first->pos="<<it->first->pos<<endl;
      schedule.push_back(next->first->pos);
      schedule.duration=new_duration;
      it=next;
      next++;
    }//end while

    //cout<<"schedule.duration="<<schedule.duration<<" batter="<<m_battery<<endl;
    //given the schedule.duration determine how many chickens are needed
    //schedule.chicken_needed=(int)ceil(lcm( (int)(schedule.duration+m_charging), (int)m_latency)*1.0f/m_latency);
    schedule.insert(schedule.end(), it->first->path2station.rbegin(), it->first->path2station.rend() );
    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);

    //cout<<"schedule size="<<schedule.nodes.size()<<endl;
    return it;
}


void
MyPCoverPlanner::build_valid_schedule_from_tsp
(const MyPCoverPlanner::TSP& tour,
 MyPCoverPlanner::TSP::const_iterator start,
 vector<MySchedule>& schedules)
{
    auto it=start; //the start of the schedule
    MySchedule schedule;
    float arrival=it->first->time2station; //arrival time

    //first station must be charging station
    if(it->first!=m_charging_station)
    {
      auto & path=it->first->path2station;
      schedule.insert(schedule.end(), path.begin(), path.end() );
      list<Node *> nodes=visitedNodes(path,0);
      //schedule.nodes.insert(nodes.begin(),nodes.end());
      schedule.nodes.insert(schedule.nodes.end(),nodes.begin(),nodes.end());
      schedule.nodes.push_back(it->first);
    }
    else
    {
      schedule.push_back(it->first->pos);
      //schedule.nodes.insert(it->first);
      schedule.nodes.push_back(it->first);
    }

    schedule.duration=it->first->time2station*2; //round trip
    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);
    auto next=it;
    next++;

    while( next!=tour.end() )
    {
      if(arrival!=schedule.duration-it->first->time2station)
      {
        cerr<<"! WRONG!!!! arrival="<<arrival<<" but="<<schedule.duration-it->first->time2station<<endl;
      }
      float new_arrival=arrival+it->second;
      float new_duration=new_arrival+next->first->time2station;
      if(new_arrival>m_latency) break; //arrived after latency
      if(new_duration>this->m_battery+11) break; //out of battery
      //if(new_duration+m_charging>m_latency) break; //

      int new_chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);
      if(new_chicken_needed>schedule.chicken_needed)
      {
        MySchedule tmp=schedule;
        //path back to the station
        auto path=it->first->path2station;
        tmp.insert(tmp.end(),path.rbegin(),path.rend());
        /*path.reverse();
        list<Node *> nodes=visitedNodes(path,arrival);
        tmp.nodes.insert(nodes.begin(),nodes.end());*/

        //schedules.push_back(tmp);

        //cout<<"schedule.chicken_needed="<<schedule.chicken_needed<<endl;
        schedule.chicken_needed=new_chicken_needed;
      }

      //cout<<"it->first->pos="<<it->first->pos<<endl;
      schedule.push_back(next->first->pos);
      //schedule.nodes.insert(next->first);
      schedule.nodes.push_back(next->first);
      schedule.duration=new_duration;
      arrival=new_arrival;
      it=next;
      next++;
    }//end while

    //cout<<"schedule.duration="<<schedule.duration<<" batter="<<m_battery<<endl;
    //given the schedule.duration determine how many chickens are needed
    //schedule.chicken_needed=(int)ceil(lcm( (int)(schedule.duration+m_charging), (int)m_latency)*1.0f/m_latency);
    auto path=it->first->path2station;
    //path.pop_front();
    schedule.insert(schedule.end(), path.rbegin(), path.rend() );
    path.reverse();
    list<Node *> nodes=visitedNodes(path,arrival);
    //schedule.nodes.insert(nodes.begin(),nodes.end());
    schedule.nodes.insert(schedule.nodes.end(),nodes.begin(),nodes.end());

    // {//clean up a bit
    //   set<Node*> tmp(schedule.nodes.begin(),schedule.nodes.end());
    //   schedule.nodes=list<Node*>(tmp.begin(),tmp.end());
    // }

    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);
    //cout<<"schedule.chicken_needed="<<schedule.chicken_needed<<endl;
    //cout<<"schedule size="<<schedule.nodes.size()<<endl;
    schedules.push_back(schedule);
    //cout<<"-------------------------"<<endl;
}


//collision between two
bool MyPCoverPlanner::collision_detection(const Point2d& pos1, const Point2d& pos2)
{
  Vector2d vec=(pos2-pos1);
  float dist=vec.norm();
  vec=vec/dist;
  for(int i=0;i<dist;i++)
  {
    Point2d pos=pos1+vec*i;
    if(collision_detection(pos)) return true;
  }
  return collision_detection(pos2);
}


//return true if m_agent collide with a non-movable object
//at a given location
bool MyPCoverPlanner::collision_detection(const Point2d& pos)
{
  //brute force collision detection
  Point2d pos_backup(m_agent->getX(),m_agent->getY());
  m_agent->tranlateTo(pos[0], pos[1]);
  bool collision=false;
  for(auto obst : m_scene->get_agents())
  {
    if( obst->is_movable() || obst==m_agent) continue;
    if( obst->collide(m_agent) )
    {
      collision=true;
      break;
    }
  }//end obst

  //move the agent back
  m_agent->tranlateTo(pos_backup[0], pos_backup[1]);
  return collision;
}

void MyPCoverPlanner::update() //update the timmer of the grid
{
  //cout<<"update"<<endl;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;
      n.t+=getMyGame()->getTimeStep(); //advanced this much
    }
  }

  //go through all agents to reset the timer
  //float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  //float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;
  for(auto agent : m_scene->get_agents())
  {
    if( !agent->is_movable() ) continue;
    Node * n=getNode(agent->getX(),agent->getY()); //&m_grid[(int)(agent->getY()/cell_h)][(int)(agent->getX()/cell_w)];
    n->t=0;
  }//end obst
}

//note start must be in subg
void MyPCoverPlanner::
tsp(const vector<Node *>& subg, Node * start,
    vector<MyPCoverPlanner::TSP>& TSPs, int number)
{
  assert(find(subg.begin(),subg.end(),start)!=subg.end());

  //prepare the matrix
  int size=subg.size();
  int init_weight=(size<10)?9999:9999999; //somehow if the graph is too small, we can't use large weights...
  vector< vector< int >  > matrix = vector< vector< int >  >(size, vector< int >(size,init_weight));
  int edge_count=0;
  for(int i=0;i<size;i++)
  {
    const Node * n=subg[i];
    matrix[n->id][n->id]=0;

    for(auto& e : n->neighbors)
    {
      const Node * nei = e.first;
      if(nei->flag!=n->flag) continue;
      matrix[n->id][nei->id]=(int)e.second;
      matrix[nei->id][n->id]=(int)e.second;
      edge_count++;
    }//end nei
  }//end i

  cout<<"edge_count="<<endl;

  //find tsp
  GraphTSP solver;
  vector<GraphTSP::TSPPath> paths;
  solver.FindTSPConcorde(matrix, paths, number);

  for(int i=0;i<paths.size();i++)
  {
    list< pair<Node *, float> > tsp;
    //cout<<"->";
    for(auto& n : paths[i])
    {
      //cout<<n.first<<", ";
      tsp.push_back(make_pair(subg[n.first],n.second));
    }
    //cout<<endl;
    assert(tsp.size()==subg.size());
    //make surea that the path starts at "start"
    while(tsp.front().first!=start)
    {
      tsp.push_back(tsp.front());
      tsp.pop_front();
    }
    TSPs.push_back(TSP(tsp.begin(),tsp.end()));
  }//end for i
}

void MyPCoverPlanner::
tsp(MyPCoverPlanner::Node * start,vector<MyPCoverPlanner::TSP>& TSPs, int number)
{
  vector<Node *> all_nodes;
  int id=0;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;
      n.id=id++;
      all_nodes.push_back(&n);
    }
  }

  return tsp(all_nodes,start,TSPs,number);
}

//generate constranits
void MyPCoverPlanner::generate_constraints( const vector<MySchedule>& schedules,  list<LP_constraints>& constraints)
{
  map< Node *, set<int> > node2schdules; //which schedules go through each node
  int size=schedules.size();
  for( int i=0;i<size;i++ )
  {
    const MySchedule & schedule=schedules[i];
    for(Node * node : schedule.nodes )
    {
      node2schdules[node].insert(i);
    }
  }//end for

  //create constraints for each node
  for(auto & cons : node2schdules)
  {
    LP_constraints lpc;
    lpc.vids=vector<int>(cons.second.begin(),cons.second.end());
    lpc.type=GLP_LO;
    lpc.lower_bound=1;
    constraints.push_back(lpc);
  }

}

bool MyPCoverPlanner::SolveLP(
  vector<MySchedule>& schdules,
  list<LP_constraints>& constaints,
  vector<float>& solution)
{
	int constraint_size = constaints.size();
	int variable_size = schdules.size();
  glp_term_out(GLP_OFF);

	glp_prob * lp = glp_create_prob();
	assert(lp);
	glp_set_prob_name(lp, "lp");
	glp_set_obj_dir(lp, GLP_MIN);
	glp_add_rows(lp, constraint_size);
	glp_add_cols(lp, variable_size);

	//init rows
	int iaja_size = 0;
	int row_id = 1;

	char tmp[64];
	for (auto & c : constaints)
	{
		sprintf(tmp, "r%08d", row_id);
		glp_set_row_name(lp, row_id, tmp);
		glp_set_row_bnds(lp, row_id, c.type, c.lower_bound, c.upper_bound);
		iaja_size += c.vids.size();
		row_id++;
	}

	//init cols
	for (int i = 1; i <= variable_size; i++)
	{
		char tmp[64];
		sprintf(tmp, "s%08d", i);
		glp_set_col_name(lp, i, tmp);
		//MIP
		glp_set_col_kind(lp, i, GLP_BV);
		//MIP
		{
			//auto & e = m->edges[i - 1];
			//const auto  & vec = m->vertices[e.vid[0]].p - m->vertices[e.vid[1]].p;
			glp_set_obj_coef(lp, i, schdules[i-1].chicken_needed);
		}

	}//end i

	//init ia, ja, and ar
	int * ia = new int[1 + iaja_size];
	int * ja = new int[1 + iaja_size];
	double * ar = new double[1 + iaja_size];
	assert(ia && ja && ar);

	int ia_id = 1;
	row_id = 1;
	for (auto & c : constaints)
	{
		for (auto vid : c.vids)
		{
			ia[ia_id] = row_id;
			ja[ia_id] = vid + 1;
			ar[ia_id] = 1;
			ia_id++;
		}//end for j

		row_id++;
	}//end for i


	glp_load_matrix(lp, iaja_size, ia, ja, ar);

	//assert(glp_simplex(lp, NULL) == 0);
	//assert(glp_get_status(lp) == GLP_OPT);

	glp_iocp parm;
	glp_init_iocp(&parm);
	parm.pp_tech = GLP_PP_ALL;
	parm.presolve = GLP_ON;
	parm.clq_cuts = GLP_ON;
	parm.binarize = GLP_ON;
	//parm.cb_func = callback;
	parm.cb_info = this;

	parm.tm_lim = 60000; //60 sec
	int err = glp_intopt(lp, &parm);
	//cout << "err=" << err << endl;

	double z = glp_mip_obj_val(lp);
	//cout << "objective value=" << z << endl;


	//get mip status
	int glp_prim_stat = glp_mip_status(lp);

/*
	switch (glp_prim_stat)
	{
	case GLP_OPT: cout << "solution is optimal;" << endl; break;
	case GLP_FEAS: cout << "solution is feasible;" << endl; break;
	case GLP_INFEAS: cout << "solution is infeasible;" << endl; break;
	case GLP_NOFEAS: cout << "problem has no feasible solution;" << endl; break;
	case GLP_UNBND: cout << "problem has unbounded solution;" << endl; break;
	case GLP_UNDEF: cout << "solution is undefined." << endl; break;
	}
*/

	bool solution_found = glp_prim_stat == GLP_OPT || glp_prim_stat == GLP_FEAS;

	if (solution_found)
	{
		for (int i = 1; i <= variable_size; i++)
		{
			double x = glp_mip_col_val(lp, i);
			solution.push_back(x);
		}
	}

	glp_delete_prob(lp);
	delete[] ia;
	delete[] ja;
	delete[] ar;

	return solution_found;
}


int MyPCoverPlanner::SolveLP(vector<MySchedule>& schedules, vector<MySchedule>& opt)
{
    //build constraints
    list<LP_constraints> constraints;
    vector<float> solution; //0/1
    int total_chickens_needed=0;
    generate_constraints(schedules, constraints);

    if(this->m_num_valid_cells<=0)
    {
      cerr<<"! Error: Number of valid cells="
          <<this->m_num_valid_cells<<endl;
      exit(1);
    }

    if(m_num_valid_cells!=constraints.size())
    {
      cerr<<"! Error: LP constraint size inconsistent;"
          <<" expect "<<m_num_valid_cells<<", get "<<constraints.size()<<endl;
      exit(1);
    }

    //cout<<"constraints size="<<constraints.size()<<endl;
    //cout<<"schedules size="<<schedules.size()<<endl;
    if( SolveLP(schedules, constraints, solution) )
    {
      int size=solution.size();
      for(int i=0;i<size;i++){
        if(solution[i]!=0){
          opt.push_back(schedules[i]);
          total_chickens_needed+=schedules[i].chicken_needed;
        }
      }//end for i
    }
    else  //failed...no LP solved
      return -1;

    // cout<<"- Best schedule needs "<<total_chickens_needed
    //     <<" chickens and "<<m_schedules.size()<<" tours"<<endl;

    return total_chickens_needed;
}

void MyPCoverPlanner::dijkstra(Node * root)
{
  vector<Node *> open;

  open.push_back(root);
  make_heap(open.begin(),open.end(), compareNode);
  root->parent=NULL;
  root->dist=0;

  while(open.empty()==false)
  {
    Node * n = open.front();
    pop_heap(open.begin(),open.end(), compareNode);
    open.pop_back();

    if(n->visited) continue; //already popped
    n->visited=true;

    for(auto& nei : n->neighbors)
    {
      Node * nn=nei.first;
      if(nn->visited) continue;
      float new_d=n->dist+nei.second;
      if(new_d<nn->dist)
      {
        bool fresh=(nn->parent==NULL && nn!=root);
        nn->dist=new_d;
        nn->parent=n;
        if(fresh){
          open.push_back(nn);
          push_heap(open.begin(),open.end(), compareNode);
        }
        else{
          make_heap(open.begin(),open.end(), compareNode);
        }
      }//end for nei
    }//end nei
  }//end while

  //exit(0);

  //
  // //now collect childrens
  // for(int i=0;i<m_height;i++)
  // {
  //   for(int j=0;j<m_width;j++)
  //   {
  //     Node & n=m_grid[i][j];
  //     if(!n.free) continue;
  //     for(auto& nei : n.neighbors)
  //     {
  //       Node * nn=nei.first;
  //       if(nn->parent==&n) n.children.push_back(nn);
  //     }
  //   }//end j
  // }//end i

}

//compute path from each node to the charging station
bool MyPCoverPlanner::paths2station()
{
  //brute force.... this can be done much more efficient
  this->m_num_valid_cells=0;
  m_charging_station->path2station.push_back(m_charging_station->pos);

  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      this->m_num_valid_cells++;

      if(&n==m_charging_station) continue;

      n.dist2station=m_agent->pathing(m_charging_station->pos, n.pos, n.path2station);
      n.time2station = dist2time(n.dist2station);
      if(n.time2station>m_latency){
        cerr<<"! Error: shortest time to station ("<<n.time2station<<") is greater than the latency ("<<m_latency<<")"<<endl;
        return false;
      }
      if(n.time2station>m_battery/2){
        cerr<<"! Error: Insufficient battery power ("<<m_battery<<") to safely reach and return from some areas ("<<n.time2station<<")"<<endl;
        return false;
      }
    }
  }//end j

  return true;//everything looks good!
}

void MyPCoverPlanner::display()
{

  //draw nodes
  SDL_Rect box; //create a rect
  box.w=(int)(getMyGame()->getScreenWidth()*0.50f/m_width);
  box.h=(int)(getMyGame()->getScreenHeight()*0.50f/m_height);

  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;

      //draw node
      SDL_Renderer * renderer=getMyGame()->getRenderer();

      box.x = n.pos[0]-box.w/2;  //controls the rect's x coordinate
      box.y = n.pos[1]-box.h/2; // controls the rect's y coordinte

      if(n.b_charging_station){
        SDL_SetRenderDrawColor(renderer,0,250,0,0);
        SDL_RenderFillRect(renderer,&box);
      }
      else{
        SDL_SetRenderDrawBlendMode(renderer,SDL_BLENDMODE_BLEND);
        //cout<<m_latency<<endl;
        float s=std::min(1.0f, n.t*1.0f/m_latency);
        if(s<1) SDL_SetRenderDrawColor(renderer,200,0,0,s*s*255);
        else SDL_SetRenderDrawColor(renderer,0,0,0,255);
        SDL_RenderFillRect(renderer,&box);
        SDL_SetRenderDrawBlendMode(renderer,SDL_BLENDMODE_NONE);

        SDL_SetRenderDrawColor(renderer,0,250,0,0);
        SDL_RenderDrawRect(renderer,&box);
      }

      //draw connections
      for(auto & N : n.neighbors)
      {
        Node * nei = N.first;
        if(n.id>nei->id) continue;
        if(n.parent==nei || nei->parent==&n)
          SDL_SetRenderDrawColor(renderer,255,255,0,000);
        else
          SDL_SetRenderDrawColor(renderer,180,180,180,000);
        SDL_RenderDrawLine(renderer, n.pos[0], n.pos[1], nei->pos[0], nei->pos[1]);
      }
    }
  }

  //draw shortest paths to each node
  /*
  SDL_Renderer * renderer=getMyGame()->getRenderer();
  SDL_SetRenderDrawColor(renderer,0,0,200,100);
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;

      //draw path
      // auto & waypt=n.path2station.front();
      // SDL_RenderDrawLine(renderer, x, y, waypt[0], waypt[1]);
      for(auto i = n.path2station.begin();i!=n.path2station.end();i++)
      {
        auto j=i; j++;
        if(j==n.path2station.end()) continue;
        SDL_RenderDrawLine(renderer, (*i)[0], (*i)[1], (*j)[0], (*j)[1]);
      }//end i

    }
  }
  */
}

MyPCoverPlanner::Node * MyPCoverPlanner::getNode(float x, float y)
{
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;
  return &m_grid[(int)(y/cell_h)][(int)(x/cell_w)];
}

list<MyPCoverPlanner::Node *>
MyPCoverPlanner::visitedNodes(const list<Point2d>& path, float arrival_time)
{
  list<MyPCoverPlanner::Node *> nodes;
  Point2d pre=path.front();
  float travel_time=arrival_time;

  for(const Point2d& pos : path)
  {
    travel_time+=(pos-pre).norm();
    if(travel_time>this->m_latency) break; //visited after latency expires...
    Node * n = getNode(pos[0],pos[1]);
    pre=pos;
    if(!n->free) continue;
    if(nodes.empty()) nodes.push_back(n);
    else if(nodes.back()!=n) nodes.push_back(n);
  }
  return nodes;
}

}//end namespace GMUCS425
