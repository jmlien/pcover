#include "MyPCoverPlanner.h"
#include "MyGame.h"
#include "MyDragonAgent.h"
#include "tsp/GraphTSP.h"
#include <algorithm>
#include "glpk/glpk.h" //linear programming solver
#include <map>

using namespace mathtool;

namespace GMUCS425
{

int gcd(int a, int b)
{
    for (;;)
    {
        if (a == 0) return b;
        b %= a;
        if (b == 0) return a;
        a %= b;
    }
    return 0;
}

int lcm(int a, int b)
{
    int temp = gcd(a, b);
    return temp ? (a / temp * b) : 0;
}

float MyPCoverPlanner::dist2time(float dist)
{
  return (float)ceil(dist*5);//distance * 5 = time to travel
}

//estimate the cost of travelling from pos1 to pos2
//scaled using the values generated by Perlin noise
float MyPCoverPlanner::cost(const Point2d& pos1, const Point2d& pos2)
{
  return dist2time((pos1-pos2).norm());

  const Uint32 * terrain = m_scene->get_terrain();
  int terrain_width = getMyGame()->getScreenWidth();
  int terrain_height = getMyGame()->getScreenHeight();
  Point2d mid( (pos1[0]+pos2[0])/2, (pos1[1]+pos2[1])/2 );
  Uint32 watery=terrain[((int)mid[1])*terrain_width+((int)mid[0])] & 255;
  float scale=sqrt(sqrt(watery*1.0f/255)); //0~1
  return (1+scale) * (pos1-pos2).norm();
}

//------------
bool MyPCoverPlanner::build() //build a grid or graph
{
  if(!m_grid.empty()) return false; //build only if the grid is empty

  m_grid=std::vector< std::vector<Node> >( m_height, std::vector<Node>(m_width,Node()) );
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  //TODO: go through the nodes, and init the data for each node
  int nid=0;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      n.id=nid++;
      n.pos.set( cell_w*(j+0.5f), cell_h*(i+0.5f) );
      //check if the node is free of collision
      n.free = !collision_detection(n.pos);
      //cout<<"node ("<<j<<","<<i<<") is free="<<n.free<<endl;
    }//end j
  }//end i

  //Make connections
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      //connect the neighboring cells
      for(int dx=-1;dx<2;dx++)
      {
        int nj=j+dx;
        if(nj<0 || nj>=m_width) continue;
        for(int dy=-1;dy<2;dy++)
        {
          int ni=i+dy;
          if(ni<0 || ni>=m_height) continue;
          Node & nei = m_grid[ni][nj];
          if(&nei==&n) continue; //the node itself

          if(collision_detection(n.pos, nei.pos)) continue; //not passable
          float dist=cost(n.pos, nei.pos);
          if(nei.free) n.neighbors.push_back( make_pair(&nei,dist));
        }//end for dy
      }//end for dx
      //cout<<"n has "<<n.neighbors.size()<<" neis"<<endl;
    }//end j
  }//end i

  return true;
}

//compute path from each node to the charging station
bool MyPCoverPlanner::paths2station()
{
  //brute force.... this can be done much more efficient
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      if(&n==m_charging_station) continue;
      n.dist2station=m_agent->pathing(m_charging_station->pos, n.pos, n.path2station);
      n.time2station = dist2time(n.dist2station);
      if(n.time2station>m_latency){
        cerr<<"! Error: shortest time to station ("<<n.time2station<<") is greater than the latency ("<<m_latency<<")"<<endl;
        return false;
      }
      if(n.time2station>m_battery/2){
        cerr<<"! Error: Insufficient battery power ("<<m_battery<<") to safely reach and return from some areas ("<<n.time2station<<")"<<endl;
        return false;
      }
    }
  }//end j

  return true;//everything looks good!
}

// //check if the schedule with the new duration would be valid
// bool MyPCoverPlanner::isvalid(MySchedule& s, Node * new_n)
// {
//   if(new_duration>this->m_battery+10) return false;
//   if(new_duration>this->)
// }

//schedule
bool MyPCoverPlanner::schedule( const Point2d& start )
{
  m_schedules.clear();

  //check if the start is valid (i.e., inside the screen)
  if(start[0]<0 || start[1]>=getMyGame()->getScreenWidth()) return false;

  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  Node * S=&m_grid[(int)(start[1]/cell_h)][(int)(start[0]/cell_w)];
  if(m_charging_station!=NULL) m_charging_station->b_charging_station=false;
  S->b_charging_station = true;
  m_charging_station=S;

  //compute path to charging station
  cout<<"- Compute all paths from charging station"<<endl;
  if( paths2station()==false ) return false;

  //schedule!
  if(m_opt_method=="tsp_greedy")
    schedule_tsp_segments_greedy();
  else if(m_opt_method=="tsp_lp")
    schedule_tsp_segments_lp();
  else{
    cerr<<"! Error: Unknown pcover optimization method: "<<m_opt_method<<endl;
    return false;
  }

  //
  return true;
}

bool MyPCoverPlanner::schedule_tsp_segments_lp()
{
  //
  int trials=10;
  vector<TSP> tours;
  tsp(m_charging_station,tours,trials);
  //assert(tour.front().first==m_charging_station);

  int best_tour=0;
  int min_chickens_needed=INT_MAX;
  vector<MySchedule> best_m_schedules;

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    //int total_chickens_needed=0;

    vector<MySchedule> schedules;
    m_schedules.clear();
    //break TSP into segments
    for(auto it=tour.begin(); it!=tour.end(); it++)
    {
        //MySchedule schedule;
        build_valid_schedule_from_tsp(tour, it, schedules);
        //schedules.push_back(schedule);
    }//end for tour

    //cout<<"schedules.size()="<<schedules.size()<<endl;

    //build constraints
    list<LP_constraints> constraints;
    vector<float> solution; //0/1
    int total_chickens_needed=0;
    generate_constraints(schedules, constraints);

    //cout<<"constraints size="<<constraints.size()<<endl;
    if( SolveLP(schedules, constraints, solution) )
    {
      int size=solution.size();
      for(int i=0;i<size;i++){
        if(solution[i]!=0){
          m_schedules.push_back(schedules[i]);
          total_chickens_needed+=schedules[i].chicken_needed;
        }
      }//end for i
    }
    else continue;

    //check if this schedule is better
    if(total_chickens_needed<min_chickens_needed)
    {
      min_chickens_needed=total_chickens_needed;
      best_m_schedules=m_schedules;
    }

  }//end for i

  //failed...no LP solved
  if(min_chickens_needed==INT_MAX) return false;

  cout<<"- Best schedule needs "<<min_chickens_needed<<" chickens and "<<best_m_schedules.size()<<" tours"<<endl;
  m_schedules=best_m_schedules;
  return true;

}//end MyPCoverPlanner

void MyPCoverPlanner::schedule_tsp_segments_greedy()
{
  //
  int trials=10;
  vector<TSP> tours;
  tsp(m_charging_station,tours,trials);
  //assert(tour.front().first==m_charging_station);

  int best_tour=0;
  int min_chickens_needed=INT_MAX;
  vector<MySchedule> best_m_schedules;

  for(int i=0;i<tours.size();i++)
  {
    TSP& tour=tours[i];
    int total_chickens_needed=0;
    m_schedules.clear();
    //break TSP into segments
    for(TSP::const_iterator it=tour.begin(); it!=tour.end(); it++)
    {
      MySchedule schedule;
      it=build_valid_schedule_from_tsp(tour, it, schedule);
      total_chickens_needed+=schedule.chicken_needed;
      m_schedules.push_back(schedule);
    }//end for tour

    cout<<"trial #"<<i<<" needs "<<total_chickens_needed<<" chickens"<<endl;
    if(total_chickens_needed<min_chickens_needed)
    {
      min_chickens_needed=total_chickens_needed;
      best_m_schedules=m_schedules;
    }
  }//end for i trials

  cout<<"- Best schedule needs "<<min_chickens_needed<<" chickens and "<<best_m_schedules.size()<<" tours"<<endl;
  m_schedules=best_m_schedules;
}


MyPCoverPlanner::TSP::const_iterator
MyPCoverPlanner::build_valid_schedule_from_tsp
(const MyPCoverPlanner::TSP& tour,
 MyPCoverPlanner::TSP::const_iterator start,
 MySchedule& schedule)
{
    auto it=start; //the start of the schedule

    //first station must be charging station
    if(it->first!=m_charging_station)
    {
      schedule.insert(schedule.end(), it->first->path2station.begin(), it->first->path2station.end() );
      list<Node *> nodes=visitedNodes(it->first->path2station);
      schedule.nodes.insert(schedule.nodes.end(),nodes.begin(),nodes.end());
    }
    else
    {
      schedule.push_back(it->first->pos);
      schedule.nodes.push_back(it->first);
    }

    schedule.duration=it->first->time2station*2; //round trip
    auto next=it;
    next++;

    while( next!=tour.end() )
    {
      float new_arrival=schedule.duration-it->first->time2station+it->second;
      float new_duration=new_arrival+next->first->time2station;
      if(new_arrival>m_latency) break; //arrived after latency
      if(new_duration>this->m_battery+10) break; //out of battery
      //if(new_duration+m_charging>m_latency) break; //

      //cout<<"it->first->pos="<<it->first->pos<<endl;
      schedule.push_back(next->first->pos);
      schedule.nodes.push_back(next->first);
      schedule.duration=new_duration;
      it=next;
      next++;
    }//end while

    //cout<<"schedule.duration="<<schedule.duration<<" batter="<<m_battery<<endl;
    //given the schedule.duration determine how many chickens are needed
    //schedule.chicken_needed=(int)ceil(lcm( (int)(schedule.duration+m_charging), (int)m_latency)*1.0f/m_latency);
    schedule.insert(schedule.end(), it->first->path2station.rbegin(), it->first->path2station.rend() );
    list<Node *> nodes=visitedNodes(it->first->path2station);
    schedule.nodes.insert(schedule.nodes.end(),nodes.begin(),nodes.end());
    {//clean up a bit
      set<Node*> tmp(schedule.nodes.begin(),schedule.nodes.end());
      schedule.nodes=list<Node*>(tmp.begin(),tmp.end());
    }
    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);

    cout<<"schedule size="<<schedule.nodes.size()<<endl;
    return it;
}


void
MyPCoverPlanner::build_valid_schedule_from_tsp
(const MyPCoverPlanner::TSP& tour,
 MyPCoverPlanner::TSP::const_iterator start,
 vector<MySchedule>& schedules)
{
    auto it=start; //the start of the schedule
    MySchedule schedule;

    //first station must be charging station
    if(it->first!=m_charging_station)
    {
      schedule.insert(schedule.end(), it->first->path2station.begin(), it->first->path2station.end() );
    }

    schedule.push_back(it->first->pos);
    schedule.nodes.push_back(it->first);

    schedule.duration=it->first->time2station*2; //round trip
    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);
    auto next=it;
    next++;

    while( next!=tour.end() )
    {
      float new_arrival=schedule.duration-it->first->time2station+it->second;
      float new_duration=new_arrival+next->first->time2station;
      if(new_arrival>m_latency) break; //arrived after latency
      if(new_duration>this->m_battery+10) break; //out of battery
      //if(new_duration+m_charging>m_latency) break; //

      int new_chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);
      if(new_chicken_needed>schedule.chicken_needed)
      {
        MySchedule tmp=schedule;
        tmp.insert(tmp.end(), it->first->path2station.rbegin(), it->first->path2station.rend() );
        schedules.push_back(tmp);
        //cout<<"schedule.chicken_needed="<<schedule.chicken_needed<<endl;
        schedule.chicken_needed=new_chicken_needed;
      }

      //cout<<"it->first->pos="<<it->first->pos<<endl;
      schedule.push_back(next->first->pos);
      schedule.nodes.push_back(next->first);
      schedule.duration=new_duration;
      it=next;
      next++;
    }//end while

    //cout<<"schedule.duration="<<schedule.duration<<" batter="<<m_battery<<endl;
    //given the schedule.duration determine how many chickens are needed
    //schedule.chicken_needed=(int)ceil(lcm( (int)(schedule.duration+m_charging), (int)m_latency)*1.0f/m_latency);
    schedule.insert(schedule.end(), it->first->path2station.rbegin(), it->first->path2station.rend() );
    schedule.chicken_needed=(int)ceil((schedule.duration+m_charging)*1.0f/m_latency);
    //cout<<"schedule.chicken_needed="<<schedule.chicken_needed<<endl;
    //cout<<"schedule size="<<schedule.nodes.size()<<endl;
    schedules.push_back(schedule);
    //cout<<"-------------------------"<<endl;
}


//collision between two
bool MyPCoverPlanner::collision_detection(const Point2d& pos1, const Point2d& pos2)
{
  Vector2d vec=(pos2-pos1);
  float dist=vec.norm();
  vec=vec/dist;
  for(int i=0;i<dist;i++)
  {
    Point2d pos=pos1+vec*i;
    if(collision_detection(pos)) return true;
  }
  return collision_detection(pos2);
}


//return true if m_agent collide with a non-movable object
//at a given location
bool MyPCoverPlanner::collision_detection(const Point2d& pos)
{
  //brute force collision detection
  Point2d pos_backup(m_agent->getX(),m_agent->getY());
  m_agent->tranlateTo(pos[0], pos[1]);
  bool collision=false;
  for(auto obst : m_scene->get_agents())
  {
    if( obst->is_movable() || obst==m_agent) continue;
    if( obst->collide(m_agent) )
    {
      collision=true;
      break;
    }
  }//end obst

  //move the agent back
  m_agent->tranlateTo(pos_backup[0], pos_backup[1]);
  return collision;
}

void MyPCoverPlanner::update() //update the timmer of the grid
{
  //cout<<"update"<<endl;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;
      n.t+=getMyGame()->getTimeStep(); //advanced this much
    }
  }

  //go through all agents to reset the timer
  //float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  //float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;
  for(auto agent : m_scene->get_agents())
  {
    if( !agent->is_movable() ) continue;
    Node * n=getNode(agent->getX(),agent->getY()); //&m_grid[(int)(agent->getY()/cell_h)][(int)(agent->getX()/cell_w)];
    n->t=0;
  }//end obst
}

//note start must be in subg
void MyPCoverPlanner::
tsp(const vector<Node *>& subg, Node * start,
    vector<MyPCoverPlanner::TSP>& TSPs, int number)
{
  assert(find(subg.begin(),subg.end(),start)!=subg.end());

  //prepare the matrix
  int size=subg.size();
  vector< vector< int >  > matrix = vector< vector< int >  >(size, vector< int >(size,999999));
  for(int i=0;i<size;i++)
  {
    const Node * n=subg[i];
    matrix[n->id][n->id]=0;

    for(auto& e : n->neighbors)
    {
      const Node * nei = e.first;
      matrix[n->id][nei->id]=(int)e.second;
      matrix[nei->id][n->id]=(int)e.second;
    }//end nei
  }//end i

  //find tsp
  GraphTSP solver;
  vector<GraphTSP::TSPPath> paths;
  solver.FindTSPConcorde(matrix, paths, number);

  for(int i=0;i<paths.size();i++)
  {
    list< pair<Node *, float> > tsp;
    for(auto& n : paths[i])
    {
      //cout<<n.first<<", ";
      tsp.push_back(make_pair(subg[n.first],n.second));
    }
    //cout<<endl;
    assert(tsp.size()==subg.size());
    //make surea that the path starts at "start"
    while(tsp.front().first!=start)
    {
      tsp.push_back(tsp.front());
      tsp.pop_front();
    }
    TSPs.push_back(TSP(tsp.begin(),tsp.end()));
  }//end for i
}

void MyPCoverPlanner::
tsp(MyPCoverPlanner::Node * start,vector<MyPCoverPlanner::TSP>& TSPs, int number)
{
  vector<Node *> all_nodes;
  int id=0;
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;
      n.id=id++;
      all_nodes.push_back(&n);
    }
  }

  return tsp(all_nodes,start,TSPs,number);
}


//generate constranits
void MyPCoverPlanner::generate_constraints( const vector<MySchedule>& schedules,  list<LP_constraints>& constraints)
{
  map< Node *, vector<int> > node2schdules; //which schedules go through each node
  int size=schedules.size();
  for( int i=0;i<size;i++ )
  {
    const MySchedule & schedule=schedules[i];
    for(Node * node : schedule.nodes )
    {
      node2schdules[node].push_back(i);
    }
  }//end for

  //create constraints for each node
  for(auto & cons : node2schdules)
  {
    LP_constraints lpc;
    lpc.vids=cons.second;
    lpc.type=GLP_LO;
    lpc.lower_bound=1;
    constraints.push_back(lpc);
  }

}



bool MyPCoverPlanner::SolveLP(
  vector<MySchedule>& schdules,
  list<LP_constraints>& constaints,
  vector<float>& solution)
{
	int constraint_size = constaints.size();
	int variable_size = schdules.size();
  glp_term_out(GLP_OFF);

	glp_prob * lp = glp_create_prob();
	assert(lp);
	glp_set_prob_name(lp, "lp");
	glp_set_obj_dir(lp, GLP_MIN);
	glp_add_rows(lp, constraint_size);
	glp_add_cols(lp, variable_size);

	//init rows
	int iaja_size = 0;
	int row_id = 1;

	char tmp[64];
	for (auto & c : constaints)
	{
		sprintf(tmp, "r%08d", row_id);
		glp_set_row_name(lp, row_id, tmp);
		glp_set_row_bnds(lp, row_id, c.type, c.lower_bound, c.upper_bound);
		iaja_size += c.vids.size();
		row_id++;
	}

	//init cols
	for (int i = 1; i <= variable_size; i++)
	{
		char tmp[64];
		sprintf(tmp, "s%08d", i);
		glp_set_col_name(lp, i, tmp);
		//MIP
		glp_set_col_kind(lp, i, GLP_BV);
		//MIP
		{
			//auto & e = m->edges[i - 1];
			//const auto  & vec = m->vertices[e.vid[0]].p - m->vertices[e.vid[1]].p;
			glp_set_obj_coef(lp, i, schdules[i-1].chicken_needed);
		}

	}//end i

	//init ia, ja, and ar
	int * ia = new int[1 + iaja_size];
	int * ja = new int[1 + iaja_size];
	double * ar = new double[1 + iaja_size];
	assert(ia && ja && ar);

	int ia_id = 1;
	row_id = 1;
	for (auto & c : constaints)
	{
		for (auto vid : c.vids)
		{
			ia[ia_id] = row_id;
			ja[ia_id] = vid + 1;
			ar[ia_id] = 1;
			ia_id++;
		}//end for j

		row_id++;
	}//end for i


	glp_load_matrix(lp, iaja_size, ia, ja, ar);

	//assert(glp_simplex(lp, NULL) == 0);
	//assert(glp_get_status(lp) == GLP_OPT);

	glp_iocp parm;
	glp_init_iocp(&parm);
	parm.pp_tech = GLP_PP_ALL;
	parm.presolve = GLP_ON;
	parm.clq_cuts = GLP_ON;
	parm.binarize = GLP_ON;
	//parm.cb_func = callback;
	parm.cb_info = this;

	parm.tm_lim = 600000; //600 sec
	int err = glp_intopt(lp, &parm);
	//cout << "err=" << err << endl;

	double z = glp_mip_obj_val(lp);
	//cout << "objective value=" << z << endl;


	//get mip status
	int glp_prim_stat = glp_mip_status(lp);

	switch (glp_prim_stat)
	{
	case GLP_OPT: cout << "solution is optimal;" << endl; break;
	case GLP_FEAS: cout << "solution is feasible;" << endl; break;
	case GLP_INFEAS: cout << "solution is infeasible;" << endl; break;
	case GLP_NOFEAS: cout << "problem has no feasible solution;" << endl; break;
	case GLP_UNBND: cout << "problem has unbounded solution;" << endl; break;
	case GLP_UNDEF: cout << "solution is undefined." << endl; break;
	}

	bool solution_found = glp_prim_stat == GLP_OPT || glp_prim_stat == GLP_FEAS;

	if (solution_found)
	{
		for (int i = 1; i <= variable_size; i++)
		{
			double x = glp_mip_col_val(lp, i);
			solution.push_back(x);
		}
	}

	glp_delete_prob(lp);
	delete[] ia;
	delete[] ja;
	delete[] ar;

	return solution_found;
}




void MyPCoverPlanner::display()
{

  //draw nodes
  SDL_Rect box; //create a rect
  box.w=(int)(getMyGame()->getScreenWidth()*0.50f/m_width);
  box.h=(int)(getMyGame()->getScreenHeight()*0.50f/m_height);

  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue;

      //draw teh node
      SDL_Renderer * renderer=getMyGame()->getRenderer();

      box.x = n.pos[0]-box.w/2;  //controls the rect's x coordinate
      box.y = n.pos[1]-box.h/2; // controls the rect's y coordinte

      if(n.b_charging_station){
        SDL_SetRenderDrawColor(renderer,0,250,0,0);
        SDL_RenderFillRect(renderer,&box);
      }
      else{
        SDL_SetRenderDrawBlendMode(renderer,SDL_BLENDMODE_BLEND);
        //cout<<m_latency<<endl;
        float s=std::min(1.0f, n.t*1.0f/m_latency);
        if(s<1) SDL_SetRenderDrawColor(renderer,200,0,0,s*s*255);
        else SDL_SetRenderDrawColor(renderer,0,0,0,255);
        SDL_RenderFillRect(renderer,&box);
        SDL_SetRenderDrawBlendMode(renderer,SDL_BLENDMODE_NONE);

        SDL_SetRenderDrawColor(renderer,0,250,0,0);
        SDL_RenderDrawRect(renderer,&box);
      }

      //draw connections
      SDL_SetRenderDrawColor(renderer,255,255,0,000);
      for(auto & N : n.neighbors)
      {
        Node * nei = N.first;
        if(n.id>nei->id) continue;
        SDL_RenderDrawLine(renderer, n.pos[0], n.pos[1], nei->pos[0], nei->pos[1]);
      }
    }
  }

  //draw paths
  SDL_Renderer * renderer=getMyGame()->getRenderer();
  SDL_SetRenderDrawColor(renderer,0,0,200,100);

    for(int i=0;i<m_height;i++)
    {
      for(int j=0;j<m_width;j++)
      {
        Node & n=m_grid[i][j];
        if(!n.free) continue;

        //draw path
        // auto & waypt=n.path2station.front();
        // SDL_RenderDrawLine(renderer, x, y, waypt[0], waypt[1]);
        for(auto i = n.path2station.begin();i!=n.path2station.end();i++)
        {
          auto j=i; j++;
          if(j==n.path2station.end()) continue;
          SDL_RenderDrawLine(renderer, (*i)[0], (*i)[1], (*j)[0], (*j)[1]);
        }//end i

      }
    }

}

MyPCoverPlanner::Node * MyPCoverPlanner::getNode(float x, float y)
{
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;
  return &m_grid[(int)(y/cell_h)][(int)(x/cell_w)];
}

list<MyPCoverPlanner::Node *>
MyPCoverPlanner::visitedNodes(const list<Point2d>& path)
{
  list<MyPCoverPlanner::Node *> nodes;
  for(const Point2d& pos : path)
  {
    Node * n = getNode(pos[0],pos[1]);
    if(nodes.empty()) nodes.push_back(n);
    else if(nodes.back()!=n) nodes.push_back(n);
  }
  return nodes;
}

}//end namespace GMUCS425
