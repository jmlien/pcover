#include "MyPathPlanner.h"
#include "MyGame.h"

using namespace mathtool;

namespace GMUCS425
{

MyPathPlanner::MyPathPlanner(MyScene * scene, MyAgent * agent)
{
  m_scene=scene;
  m_agent=agent;
}

//shorten and smooth the path
void MyPathPlanner::smooth(std::list<Point2d>& path)
{
  if(path.size()<3) return;
  auto pre=path.begin();
  auto it=pre; it++;
  auto next=it; next++;
  bool shortened=false;

  while( path.size()>=3 && next!=path.end() )
  {
    //check if
    if( collision_detection(*pre, *next) ){
      pre=it;
      it=next;
      next++;
    }
    else{
      path.erase(it);
      pre=path.begin();
      it=pre; it++;
      next=it; next++;
    }
  }//end while
}

//return true if m_agent collide with a non-movable object
//at a given location
bool MyPathPlanner::collision_detection(const Point2d& pos)
{
  //brute force collision detection
  Point2d pos_backup(m_agent->getX(),m_agent->getY());
  m_agent->tranlateTo(pos[0], pos[1]);
  bool collision=false;
  for(auto obst : m_scene->get_agents())
  {
    if( obst->is_movable() || obst==m_agent) continue;
    if( obst->collide(m_agent) )
    {
      collision=true;
      break;
    }
  }//end obst

  //move the agent back
  m_agent->tranlateTo(pos_backup[0], pos_backup[1]);
  return collision;
}



//collision between two
bool MyPathPlanner::collision_detection(const Point2d& pos1, const Point2d& pos2)
{
  Vector2d vec=(pos2-pos1);
  float dist=vec.norm();
  vec=vec/dist;
  for(int i=0;i<dist;i++)
  {
    Point2d pos=pos1+vec*i;
    if(collision_detection(pos)) return true;
  }
  return collision_detection(pos2);
}

//estimate the cost of travelling from pos1 to pos2
//scaled using the values generated by Perlin noise
float MyPathPlanner::cost(const Point2d& pos1, const Point2d& pos2)
{
  const Uint32 * terrain = m_scene->get_terrain();
  int terrain_width = getMyGame()->getScreenWidth();
  int terrain_height = getMyGame()->getScreenHeight();
  Point2d mid( (pos1[0]+pos2[0])/2, (pos1[1]+pos2[1])/2 );
  Uint32 watery=terrain[((int)mid[1])*terrain_width+((int)mid[0])] & 255;
  float scale=sqrt(sqrt(watery*1.0f/255)); //0~1
  return (1+scale) * (pos1-pos2).norm();
}

//------------
bool MyGridPathPlanner::build() //build a grid or graph
{
  if(!m_grid.empty()) return false; //build only if the grid is empty

  m_grid=std::vector< std::vector<Node> >( m_height, std::vector<Node>(m_width,Node()) );
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  //TODO: go through the nodes, and init the data for each node
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      n.pos.set( cell_w*(j+0.5f), cell_h*(i+0.5f) );
      //check if the node is free of collision
      n.free = !collision_detection(n.pos);
      //cout<<"node ("<<j<<","<<i<<") is free="<<n.free<<endl;
    }//end j
  }//end i

  //Make connections
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      if(!n.free) continue; //this node is in collision, no neighbors
      //connect the neighboring cells
      for(int dx=-1;dx<2;dx++)
      {
        int nj=j+dx;
        if(nj<0 || nj>=m_width) continue;
        for(int dy=-1;dy<2;dy++)
        {
          int ni=i+dy;
          if(ni<0 || ni>=m_height) continue;
          Node & nei = m_grid[ni][nj];
          if(&nei==&n) continue; //the node itself
          if(nei.free) n.neighbors.push_back(&nei);
        }//end for dy
      }//end for dx
      //cout<<"n has "<<n.neighbors.size()<<" neis"<<endl;
    }//end j
  }//end i

  return true;
}

//finding a path using A*
bool MyGridPathPlanner::find_path( const Point2d& start, const Point2d& goal, std::list<Point2d>& path )
{
  //check if the start and goal are valid (i.e., inside the screen)
  if(start[0]<0 || start[1]>=getMyGame()->getScreenWidth()) return false;
  if(goal[0]<0 || goal[1]>=getMyGame()->getScreenWidth()) return false;

  vector<Node *> open, close;
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  Node * S=&m_grid[(int)(start[1]/cell_h)][(int)(start[0]/cell_w)];
  Node * G=&m_grid[(int)(goal[1]/cell_h)][(int)(goal[0]/cell_w)];
  if(!S->free) cerr<<"! Error: Start point ("<<start[0]<<","<<start[1]<<") makes the agent collide with something"<<endl;
  if(!G->free) cerr<<"! Error: Goal point ("<<goal[0]<<","<<goal[1]<<") makes the agent collide with something"<<endl;

  S->visited=true;
  S->g=0;
  S->f=0;

  //cout<<"goal="<<goal<<endl;
  //cout<<"G->pos="<<G->pos<<endl;

  open.push_back(S);
  bool found=false;
  while(!open.empty())
  {
    //cout<<"open size="<<open.size()<<endl;
    pop_heap(open.begin(), open.end(), comp);
    Node * N=open.back();
    //cout<<"N->pos="<<N->pos<<endl;
    open.pop_back();
    close.push_back(N);
    if(N==G){ //path found!
      while(N!=S)
      {
        path.push_front(N->pos);
        N=N->parent;
      }
      path.push_front(S->pos);
      found=true;
      break;
    }
    //
    //cout<<"N->neighbors size="<<N->neighbors.size()<<endl;
    for(Node * nei : N->neighbors)
    {
      float new_g = N->g + cost(N->pos,nei->pos);
      float new_f = new_g + (G->pos-nei->pos).norm();
      //cout<<"nei->pos="<<nei->pos<<" nei->visited="<<nei->visited<<endl;
      if(nei->visited==false)
      {
        nei->g=new_g;
        nei->f=new_f;
        nei->parent=N;
        nei->visited=true;
        open.push_back(nei);
        push_heap(open.begin(), open.end(), comp);
      }
      else if(new_f < nei->f){
        nei->g=new_g;
        nei->f=new_f;
        nei->parent=N;
        make_heap(open.begin(), open.end(), comp);
      }
    }//end for nei
  }

  //cout<<"Path found = "<<found<<endl;
  //reset
  for(Node * n: close)
  {
      n->f=n->g=FLT_MAX;
      n->visited=false;
      n->parent=NULL;
  }

  for(Node * n: open)
  {
      n->f=n->g=FLT_MAX;
      n->visited=false;
      n->parent=NULL;
  }

  return found;
}

}//end namespace GMUCS425
